{"/java-features/java-10":{"title":"Java 10","data":{"java-10#Java 10":"","참고자료#참고자료":"Java 10의 새로운 기능 - 성능향상\nJava 10 - var 키워드로 변수선언 (지역변수 타입추론)\nJava 10 의 새로운 기능\nhttps://www.baeldung.com/java-10-overview","요약#요약":"G1 가비지 컬렉터의 Full GC 수행시 병렬기반 동작하도록 변경\nJava 10 에서는 G1 가비지 컬렉터로 Full GC 수행 시에 병렬 기반 Mark Seep Compact 알고리즘을 사용하도록 변경. 병렬 기반이기에 Full GC 시의 정지시간을 효과적을 줄여주게 되었다.\n참고 : Java 9 에서는 G1 가비지 컬렉를 이용한 Full GC 는 싱글스레드 기반 Mark Sweep Compact 알고리즘을 사용\nAppCDS\nJDK8, JDK9 에서는 상용기능이었으나, Java 10 에서는 오픈 소스이며 공개적으로 사용 가능\nGraal 컴파일러를 JIT 컴파일러로 쓸수 있게끔 제공. Java 10 에서는 Graal 컴파일러는 실험적인 기능이기에 현존하는 JIT 컴파일러보다는 더 나은 성능을 보장하지는 않는다.\nvar 키워드 도입\nvar 키워드를 사용하면 지역변수 추론시 컴파일 타임에 변수의 타입을 추론가능해짐.\n변수의 타입을 지정하지 않고 var 키워드를 사용해 변수를 선언.\n참고 - codechacha\n불변 컬렉션관련 편의성 정적 메서드 제공\ncopyOf() : 주어진 Collection 의 수정 불가능한 복사본 반환\nCollectors.toUnmodifiable() : Stream의 collect 연산시 불변 List,Map,Set으로 수집하는 연산\nOptional 에 orElseThrow 추가\n기존 get() 메서드를 사용하는 것에 비해 비교적 권장되는 편.\n컨테이너 인식 관련 지원\nXX:UseContainerSupport\nJVM이 Docker 컨테이너에서 실행되고 있는지 인식가능해짐\nXX:ActiveProcessorCount={count}\n컨테이너 내에서 구동되는 JVM이 사용할 CPU 수를 지정\nXX:InitialRAMPercentage, XX:MaxRAMPercentage, XX:MinRAMPercentage\nJava 힙의 초기 메모리 퍼센트, 최대 퍼센트, 최소 퍼센트를 지정 가능해짐\n루트인증서\nTLS 등의 중요 Security 관련 구성요소를 OpenJDK 빌드에서 기본적으로 작동하지 않던 이슈가 있었는데\nJava 10 부터는 Oracle 의 Java SE 루트 CA 프로그램에서 루트 인증서를 오픈 소스로 제공\nOpen JDK 빌드를 개발자에게 더 매력적으로 만들고 Oracle JDK 빌드 간의 차이를 줄이기 위한 Oracle 에서의 지원내용\nCLI 변경사항\njavah 도구 제거. 대신 javac -h 사용가능. (javah 는 네이티브 메서드를 구현하는 데에 필요한 c 헤더 및 소스파일을 생성시 사용했던 도구)\npolicytool 제거\n정책 파일 생성 및 관리를 위한 UI 기반 도구\njava -Xprof 옵션 제거\n실행중인 프로그램을 프로파일링, 프로파일링 데이터를 표준 출력(stdout)으로 내보내는데 사용되던 도구\n대신 jmap 도구를 사용하면 된다.\njava.security.acl\njava.security.acl 패키지는 java.security.Policy 및 관련 클래스로 대체 됨\nforRemoval = true 로 표시\njava.security.{Cirtificate, Identity, IdentityScope, Signer} 내의 API 는 모두 forRemoval = true 로 표시\n시간 기반 릴리즈 버전 관리\nJava 10 부터 Oracle 은 Java 의 시간 기반 릴리즈로 변경\n새로운 기능 릴리즈에 대한 지원은 6개월 동안만 지속\n장기 지원 릴리즈는 LTS로 표시되며 LTS에 대한 지원은 3년. Java 11 은 LTS 릴리즈\n6개월마다 새로운 Java 릴리즈. 이를 기능릴리즈라 명명\n2018년 3월 릴리즈 : JDK 10\n2018년 9월 릴리즈 : JDK 11\n기능 리리즈에 대한 지원은 다음 릴리즈까지 6개월 동안만 지속\njava -version  시 GA 날짜가 출력에 포함\nopenjdk version \"10\" 2018-03-20"}},"/":{"title":"Introduction","data":{"":"JVM\nJava 8 ~ 21 Features\nObject"}},"/java-features/java-11":{"title":"Java 11","data":{"java-11-변경-내용들#Java 11 변경 내용들":"","참고자료#참고자료":"Java 8과 비교하여 Java 11 에서는 GC가 어떻게 변했을까?\nJava 11 New Features","요약#요약":"Java 10 까지는 상업적으로 사용할 수 있는 마지막 무료 Oracle JDK 릴리즈. Java 11 부터는 Oracle의 무료 LTS가 없다. 다만, OpenJDK 를 제공하고 있다.\nJava 9 에서부터 계속해서 디폴트 GC는 G1GC\nZGC (Z Garbage Collector) 실험적 도입\n테라바이트 규모의 매우 큰 heap 을 사용하는 애플리케이션을 위한 GC\n10ms 미만의 짧은 대기 시간이 필요한 경우에 사용\nlambda 에서 var 키워드 사용 지원 추가 (대신 @NonNull 필요)\n아래에 간단한 예제 추가(!!TODO!!)\nHttpClient 추가 (Java 9 에서는 HttpRequest, Java 11 에서는 HttpClient)\nHttp 1.1, 2 를 모두 지원\njavac 컴파일 없이 바로 java Helloworld 실행 가능해짐\n성능\n상수 Pool 지원\n테스트용도 가비지수집기(Epsilon) 제공. 메모리를 할당하지만, 가비지는 수집x, 따라서 메모리 부족 오류 테스트/시뮬레이션 할때 사용가능.\nAArch64 내장함수들 최적화, java.util.Math 의 sin,cos,log 에 대한 새로운 내장함수 구현\nString 클래스에 편의성 메서드 추가\nisBlank, lins, strip, stripLeading, stripTrailing, repeat\n테스트 코드를 추가해둘 예정\nFile 클래스에 편의성 메서드 추가\nwriteString, readString\n리스트 → 배열 변환 편의 메서드 추가 (e.g. wordList.toArray(String[]::new))\nPredicate 인터페이스에 not 메서드 추가 (negate 와 유사한 역할)\nNest Class, 중첩 클래스 액세스 개념 도입\n유니코드 10 지원, 이모지 제공, 더 많은 문자 제공\n암호화 방식관련 불안전한 것들 보완, 새로운 암호화 키 계약 지원, TLS 버전 1.3 업그레이드 관련 변경사항 (참고)\n제거된 기능\nJava EE, CORBRA\nJMC, JavaFX\nJavaFX는 JDK외부에서 벼롣의 모듈세트로 사용가능, JMC는 독립형 버전의 JMC 다운로드 후 사용가능\nNashron Javascript 엔진, Jar 파일에 대한 Pack200 압축해제"}},"/java-features/java-17":{"title":"Java 17","data":{"java-17#Java 17":"","참고자료#참고자료":"JDK 17 발표 및 새로운 변화 - blogs.oracle.com\n자바17의 새로운 기능들, 3년 만에 LTS 버전 릴리즈\nJava 17로 전환을 고려해야 하는 이유\n우리팀이 JDK17을 도입한 이유\nJDK17 이제는 AdoptOpenJDK 대신 Eclipse Temurin 사용","개인적인-생각#개인적인 생각":"이 글을 처음 썼을 때는 1년전인 2023년도 3월이었고, 지금은 새로운 버전으로 글을 쓰고 있습니다. 현 시점에서 Java 보다는 Kotlin 을 선호하는 편이지만 Java 는 무시할 수 없는 가장 편한 언어로 생각하고 있습니다. 만약 프로젝트를 새로한다면 Java 17 을 선택하게 될 것 같습니다.Java 17 은 LTS 버전이며 버그픽스도 많이 되어 있는 편이기에 어느 정도의 최신 Java 스펙을 갖추고 있으면서 오랫동안 지원이 되는 Java 버전을 원한다면 Java 17 을 선택하는 것도 나쁘지 않은 선택으로 보입니다. 또한 Java 11 ~ 16 사이에 추가된 문법적인 편의성을 두루 포함하고 있습니다.","요약#요약":"LTS 주기 변경\nJDK 17 부터 LTS 버전에 대한 주기를 2년으로 변경 (JDK 17 이전에는 LTS 주기가 3년)\n2021년 9월 발표된 JDK 17의 다음 LTS 버전은 2년 후인 2023년 9월에 발표될 예정 (이글을 쓰는 현재날짜는 2023년 3월 19일)\n참고) LTS 주기 변경하기 전에는 2024년 9월 발표 예정이었다.\n새로운 라이선스 적용\nJDK 17부터는 NTFC (Oracle No-Fee Terms and Conditions) 라이선스를 적용해서 배포.\nJDK 17 이전에는 OTN (Oracle Technology Network) 라이선스.\nNTFC 라이선스에서는 개발자들이 많이 사용하는 SDKMAN 과 같은 배포,설치 툴을 이용해 Oracle JDK를 받을 수 있다. 다만, 배포의 경우 추가로 비용을 받지 않는 경우에만 허용된다. (참고. oracke jdk 배포를 의미함.)\n참고) JDK 17 기여도\nJDK Bug System 에 등록된 2645 개의 버그 중 1774개 외의 871 개의 문제점들을 다른 기관들의 참여로 이루어졌다고 함\nJEP 406, Preview. Switch~Case 문에 Pattern Matching 사용가능\ncase 문을 람다 기반으로 작성 가능하다. 이때 null 데이터도 조금 더 간편하게 다룰 수 있게 되었다.\n다만 아직 여전히 Preview 단계다.\ne.g.\npublic void printHello(String s){\r\nswitch(s){\r\ncase null -> System.out.println(\"널 이에요\"); \r\ncase \"hello\", \"world\" -> System.out.println(\"안녕하세요\");\r\ndefault -> System.out.println(\"디폴트\");\r\n}\r\n}\ncase 문에 기본타입 외에도 모든 참조 타입을 사용할 수 있게 되었다.\n이전에는 primitive 타입(기본타입), 일치하는 박스 타입(Character, Byte, Short, Integer 등), String, enum 타입만 허용됐었다.\ne.g.\nrecord Point(int i, int j) {}\r\nenum Color { RED, GREEN, BLUE; }\r\n\r\nstatic void typeTester(Object o) {\r\n\tswitch (o) {\r\n\t\tcase null     -> System.out.println(\"null\");\r\n\t\tcase String s -> System.out.println(\"String\");\r\n\t\tcase Color c  -> System.out.println(\"Color with \" + Color.values().length + \" values\");\r\n\t\tcase Point p  -> System.out.println(\"Record class: \" + p.toString());\r\n\t\tcase int[] ia -> System.out.println(\"Array of ints of length\" + ia.length);\r\n\t\tdefault       -> System.out.println(\"Something else\");\r\n\t}\r\n}\ninstanceof 사용 문법 간소화\ne.g.\n기존 : if(o instanceof String){ ... }\n자바17 : if(o instanceof String s) { ... }\n변수 s를 사용하는 코드를 if 문 안에서 사용 가능하다.\nJEP 409 sealed class\n코틀린에서 사용하는 sealed class와 거의 유사한 기능이 지원된다.\nsealed class 는 JDK15 에서 Preview (JEP 360) 로 제안되었고, JDK 16 에서 Second Preview (JEP 397)로 수정제안된 이력이 있다."}},"/java-features/java-16":{"title":"Java 16","data":{"java-16#Java 16":"","참고자료#참고자료":"Java 8 부터 16까지의 신규기능들\nZGC - JDK 16의 새로운 기능들(gc 성능 관련)","요약#요약":"text block\nJEP 359 - Records를 정식지원 시작\n자바 15의 외부메모리 접근 인큐베이팅 2차\n자바 15에 추가된 sealed 클래스의 2차 Preview\nJEP 387 : 자바 8부터 제거된 악명높은 PermGen 대신 Metaspace 방식을 지원하기 시작.\nJEP 343 : jpackage 명령어를 통해 각 운영체제별 자바 프로그램을 설치 패키지(pkg, deb, msi 등)로 생성하는 기능이 정식으로 추가되어, 자바 프로그램을 손쉽게 배포하는 기능이 추가됨\nJEP 389 : JNI를 대신할 외부 링크 방식의 인터페이스를 인큐베이팅을 통해 시작\nJEP 347 : 자바 네이티브(JNI 등) 개발 시 C++14 규격을 지원하기 시작\nJEP 338 : Vector API. 자동병렬프로세싱을 지원하는 자동 벡터 API가 추가될 예정 (Incubator)\nJEP 390 : 값 유형의 클래스를 동기화에 사용 시 경고 메시지가 개선"}},"/java-features/java-9":{"title":"Java 9","data":{"java-9#Java 9":"","참고자료#참고자료":"일반적인 GC와 G1GC\nG1GC의 라이프사이클, 장단점, heap 구조","요약#요약":"디폴트 메서드에도 package private 지정 가능\ntry with resource\n과거 방식 : try 내부 불록에 인라인으로 선언되어야 하는 방식\nJava 9 이후의 방식 : try 외부에서 자원을 선언해도 가능\n익명객체 생성 시에 다이아몬드 연산자 지원\n불변 컬렉션 API\ne.g. List.of(\"1\", \"2\", \"3\")\ne.g. Set.of(1,2,3)\ne.g. Map.of(\"1\":1, \"2\",2)\nOptional.stream()\nOptional 객체 역시 Stream 으로 처리할 수 있게 되었다.\nG1GC\nJDK 9 에서부터 G1 가비지 컬렉터가 디폴트 GC. 하지만 Java 9 까지는 Full GC는 싱글 스레드 기반 Mark Sweep Compact 알고리즘.\nRegion 을 일정한 크기로 나누어 객체를 할당한다. G1GC는 Region 을 튜닝하고 이에 따라 stop the world 를 최소화한다.\nJShll 커맨드 라인 툴 도입\n새로운 Http Client 도입 (HttpRequest)\n프로세스 API (ProcessHandle클래스)\nJCMD 커맨드 라인툴\nPublish, Subscriber 프레임워크\n통합 JVM 로깅\nJVM 로깅을 제공하는 공통 기능이 생겼는데, 각 모듈별로 독자적으로 공통기능을 사용해 독자적으로 로깅을 수행할 수 있는 로깅이 Java 9 부터 도입"}},"/jvm/compiler-interpreter-jit-compiler":{"title":"Compiler Interpreter Jit Compiler","data":{"정적-컴파일러-인터프리터-jit-컴파일러#정적 컴파일러, 인터프리터, JIT 컴파일러":""}},"/jvm":{"title":"Jvm","data":{}},"/jvm/java-code-compile-execution-processes":{"title":"Java Code Compile Execution Processes","data":{"java-코드를-컴파일하고-이것을-실행하기-까지#Java 코드를 컴파일하고 이것을 실행하기 까지":"1) .java → .class (컴파일) : JAVA 소스코드는 javac 라는 자바 컴파일러로 바이트코드로 컴파일합니다. (.class 파일이 생성됩니다.)\n2) 바이트코드 적재 : JRE ClassLoader 는 JVM에 바이트코드를 적재합니다. (JRE Class Loader → JVM)\n3) Execution Engine 으로 실행 : JVM 의 실행엔진(Execution Engine)은 바이트코드를 기계어로 변환하고 명령어 단위로 실행하는 역할을 수행합니다. (이때, 바이트 코드를 기계어로 변환할 때 사용하는 것이 JIT 컴파일러 또는 인터프리터다.)\n먼저 .java 파일로 존재하는 소스코드를 javac 를 통해 바이트 코드(.class 파일)로 변환합니다. 그리고 이렇게 변한된 바이트 코드는 JRE ClassLoader 를 통해 JVM에 적재합니다. 이렇게 적재한 바이트 코드는 JVM의 실행엔진(Execution Engine) 에 의해 번역하면서 실행되는데, 이 때 JVM의 실행엔진(Execution Engine) 은 JIT 컴파일러를 사용해 번역을 수행하게 됩니다.","1-java코드를-javac-를-이용해-바이트코드로-변환#1) Java코드를 javac 를 이용해 바이트코드로 변환":"Java 소스코드는 javac 컴파일러를 통해 .class 확장자를 가진 파일로 변환되는데, 이것을 바이트 코드라고 합니다.","2-jre-classloader-가-jvm-에-바이트코드를-적재#2) JRE ClassLoader 가 JVM 에 바이트코드를 적재":"JRE ClassLoader 는 바이트코드를 JVM에 적재합니다.","3-jvm-의-execution-engine-이-바이트코드의-번역과-실행을-수행#3) JVM 의 Execution Engine 이 바이트코드의 번역과 실행을 수행":"JVM 의 실행엔진(Execution Engine)을 이용해 바이트코드를 기계어로 변환하고 명령어 단위로 실행하는 역할을 수행합니다. (이때, 바이트 코드를 기계어로 변환할 때 사용하는 것이 JIT 컴파일러 또는 인터프리터입니다.)"}},"/jvm/what-is-garbage-collector":{"title":"What Is Garbage Collector","data":{"가비지-컬렉터란#가비지 컬렉터란?":"","참고자료#참고자료":"Oracle.com - Getting Started With the G1 Garbage Collector\nJVM 아키텍처\nJava Constant Pool","가비지garbage란#가비지(Garbage)란?":"Oracle 의 Java SE 8 GC 튜닝 가이드에서는 가비지를 아래와 같이 이야기하고 있습니다.\nAn object is considered garbage when it can no longer be reached from any pointer in the running program.\n실행 중인 프로그램에서 더 이상 어떤 포인터로도 접근이 불가능한 객체를 가비지(Garbage)로 간주합니다.\n즉, 더 이상 참조되고 있지 않은 객체는 광활한 힙 안에서 참조하는 변수 없이 혼자 있습니다. 이런 객체를 가비지(Garbage)라고 부릅니다.","가비지-컬렉터#가비지 컬렉터":"힙 메모리에서 사용되지 않는 영역의 객체들을 탐색해서 제거하는 역할을 수행합니다.\nGC가 수행되는 동안에는 아무것도 못한다. 정확히 예측하기 쉽지 않습니다.\nGC가 수행되는 동안 GC를 수행하는 스레드를 제외한 모든 스레드가 정지됩니다.\nFull GC가 일어나서 몇초간 스레드가 정지하게 되면 장애로 이어지는 치명적인 문제가 발생할 수 있습니다. (Stop the world)","가비지-컬렉터의-종류#가비지 컬렉터의 종류":"대표적인 가비지 컬렉터 들의 종류는 아래와 같습니다.\nSerial Collector\nParallel Collector\nConcurrenct Collector\nConcurrent Mark Sweep (CMS) Collector\nGarbage First Gabage Collector","가비지-컬렉터의-세대의-전환과정#가비지 컬렉터의 세대의 전환과정":"참고자료 : Oracle.com - Getting Started With the G1 Garbage Collector / ‘The G1 Garbage Collector’\n오래된 버전의 Garbage Collector 들은 Heap 을 3개의 영역으로 분류합니다.\nYoung Generation\nOld Generation\nPermanent Generation\n하지만 G1 Collector가 도입되면서 조금은 다른 접근방법을 택했습니다. 아래와 같은 방식입니다. 위와 같은 하나의 영역을 Region 이라고 부릅니다. 그리고 이 Region을 여러 단위로 해서 힙을 나누어 가비지 컬렉팅을 수행합니다.\n더 자세한 내용은 Oracle.com - Getting Started With the G1 Garbage Collector 을 참고","garbage-first-garbage-collector-g1gc#Garbage-First Garbage Collector (G1GC)":"다른 가비지 컬렉터 들에 비해 비교적 제일 나중에(최근에) 개발된 가비지 컬렉터 입니다.\r\n다국적 서비스 기업들이 많이 태동하면서 가비지 컬렉터 역시 패러다임의 전환이 이뤄졌는데, G1GC에 이런 내용들이 반영되어 많은 부분이 변화했습니다. 흔히 G1GC 라고 불리는 가비지 컬렉터입니다. G1GC는 서버 스타일의 컬렉터입니다. G1GC 는 Generational GC가 아닙니다. (G1GC는 Generation 구분을 따로 하지 않는다.)\n큰 메모리를 가진 멀티 프로세서 머신에 적합한 가비지컬렉터\nYoung Generation 영역 : Snapshot-At-The-Beginning 알고리즘을 사용\nOld Generation 영역 : Snapshot-At-The-Beginning 알고리즘을 사용\nJVM 옵션 : -XX:+UseG1GC : G1 컬렉터를 활성화","serial-collector#Serial Collector":"싱글 스레드 기반의 가비지 컬렉터\n싱글 스레드 기반이기에 싱글 프로세서 시스템에 적합\n멀티코어를 사용할 수 없다는 점이 단점\nYoung Generation 영역 : Serial 알고리즘을 사용\nOld Generation 영역 : Serial Mark-Sweep-Compact 알고리즘을 사용\nJVM 옵션 : -XX+UseSerialGC","parallel-collector#Parallel Collector":"Parallel Compaction 을 사용하면 Major GC 를 병렬로 수행합니다.\n마이너 GC를 병렬로 수행\n메이저 GC는 Parallel Compaction 을 사용할 경우에만 병렬로 수행\n멀티프로세서, 멀티 스레드 하드웨어에서 중대형 규모 애플리케이션에 적합한 GC\nJVM 옵션\n-XX:+UseParallelGC : Parallel Compaction 을 디폴트로 사용하는 옵션\n-XX:-UseParallelOldGC : Parallel Compaction 을 사용하지 않도록 명시하는 옵션","concurrent-collector#Concurrent Collector":"전체 처리율 보다 응답 시간이 더 중요할 경우에 사용합니다.\n프로세서가 GC와 처리 역할을 나누어 일을 하기에 일시 정지가 짧아집니다.\n프로세서의 수를 늘릴수록 효과를 볼 수 있지만 한계가 있습니다.\nConcurrent Collector 는 아래의 두가지가 있습니다.\nConcurrent Mark Sweep(CMS) Collector\nGarbage-First Garbage Collector (G1GC)","concurrent-mark-sweepcms-collector#Concurrent Mark Sweep(CMS) Collector":"가비지 컬렉션의 일시정지가 짧은 것이 선호되는 애플리케이션에 사용되면 좋은 컬렉터입니다.\n프로세서의 리소스를 가비지 컬렉션과 공유합니다.(프로세서가 가진 자원들을 가비지컬렉션과 공유)\nHeap 메모리 영역의 크기가 클 때 적합한 Collector\nGC의 일시 정지 시간을 줄이는 것이 목적입니다. 크기가 큰 오래된 객체가 있는 경우에 적합합니다.\nJVM 옵션 :\n-XX:+UseConcMarkSweepGC : CMS 컬렉터를 enable 하는 옵션\nYoung Generation 영역: Parallel GC 알고리즘\nOld Generation 영역 : Concurrent Mark Sweep GC 알고리즘 사용\nConcurrent Mark Sweep GC 알고리즘에 대해서는 이 문서 하단에 별도로 설명을 정리해두었습니다."}},"/java-features":{"title":"Java Features","data":{"java-features#Java Features":""}},"/jvm/minor-gc-major-gc-object-lifecycle":{"title":"Minor GC, Major GC, 객체의 생존 흐름","data":{"참고자료#참고자료":"Oracle.com - Getting Started With the G1 Garbage Collector\nhttps://1-7171771.tistory.com/140","가비지garbage-란#가비지(Garbage) 란?":"Oracle 의 Java SE 8 GC 튜닝 가이드에서는 가비지를 아래와 같이 이야기하고 있습니다.\nAn object is considered garbage when it can no longer be reached from any pointer in the running program.\n실행중인 프로그램에서 더 이상 어떤 포인터로도 접근이 불가능한 객체를 가비지(Garbage)로 간주합니다.\n즉, 더 이상 참조되고 있지 않은 객체는 광활한 힙 안에서 참조하는 변수 없이 혼자 있습니다. 이런 객체를 가비지(Garbage)라고 부릅니다.","가비지-컬렉션#가비지 컬렉션":"힙 영역에 저장되는 데이터는 프로그래머가 직접 할당할 수는 있지만 직접 해제하는 것은 불가능합니다. 이것은 JVM이 직접 관리합니다. JVM은 살아있는 객체(live objects) 외에는 모두 가비지로 간주합니다. 참조되고 있지 않은 객체는 접근 불가능(unreachable)하다고 판단하고 해당 객체를 삭제하여 메모리 공간을 획득합니다.","minor-gc-major-gc#Minor GC, Major GC":"","minor-gc#Minor GC":"New/Young 영역에서 발생하는 GC\nEden, Survivor0, Survivor1 영역에서 사용되지 않는 객체들을 삭제하는 것을 MinorGC라고 부릅니다.","major-gcfull-gc#Major GC(Full GC)":"Old 영역에서는 2차 GC라고 불리는 Major GC 가 발생합니다\nGC 작업을 진행하는 Thread 를 제외하고 그 외의 모든 Thread 를 멈춘 후 GC를 진행합니다.\n이 때 GC를 수행하는 Thread 외의 모든 Thread가 멈추는 현상을 Stop the World 라고 부릅니다. \nGC 알고리즘을 어떤 것을 사용하더라도 Stop the world 를 피하는 것은 불가능합니다. GC 튜닝을 하는 목적은 바로 Stop the world 에 소요되는 시간을 최소한도로 줄이기 위해서 입니다.","major-gc-minor-gc를-거칠-때-객체의-생존-흐름#Major GC, Minor GC를 거칠 때 객체의 생존 흐름":"힙 메모리에서의 GC 가 동작하는 흐름은 아래와 같습니다.\n출처 : https://1-7171771.tistory.com/140"}},"/java-features/java-8":{"title":"Java 8","data":{"java-8#Java 8":"꽤 오래된 버전이기에 시간이 될때 정리를 시작할 예정입니다.\nCompletableFuture, CompletableStage\nLocalDate, LocalDateTime, OffsetDateTime, ZonedDateTime\nStream API\nlambda, 함수형 인터페이스\nOptional"}},"/jvm/jvm-modules":{"title":"Jvm Modules","data":{"jvm-의-각-모듈들#JVM 의 각 모듈들":""}},"/lombok-effective-how-to/stop-using-data-annotation":{"title":"Stop Using Data Annotation","data":{"data-애노테이션은-가급적-사용을-피하자#@Data 애노테이션은 가급적 사용을 피하자":"@Data 에는 각종 어노테이션들이 숨어서 함정을 파놓고 기다리고 있기에, 가급적이면 @Setter 사용은 피하자.","data-사용의-단점-부작용#@Data 사용의 단점, 부작용":"@Setter 를 무분별하게 남용하게 된다.\n@ToString 양방향 순환 참조 문제 발생\n@EqualsAndHashCode 를 남용하게 된다.","1-setter-를-사용하는-것으로-인한-단점#1) @Setter 를 사용하는 것으로 인한 단점":"예를 들어 아래와 같은 코드가 있다고 해보자.\n@NoArgsConstructor\r\n@Data\r\n@Entity\r\npublic class Member {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n    private String email;\r\n    private String name;\r\n\r\n    @ManyToOne(fetch = FetchType.LAZY)\r\n    @JoinColumn(name = \"dept_id\")\r\n    private Department department;\r\n}\r\n흔히 setter로 데이터를 변경하는 방식은 흔히 'bean 방식' 이라고 부른다.@Data 내에는 @Setter 가 있기에 Member 객체는 setter 가 적용되어 email 을 변경할 수 있다는 의미가 된다. 그런데 만약 Member  의 email 을 변경하는 기능이 요구사항에 없다면 setter 로 인해 기능의 불일치가 발생한다. 즉, 소프트웨어의 어느 부분에서든 email 을 변경할 수 있는 소지를 남겨놓은 상태가 되어버린다.이미 한번 생성된 객체 내의 email을 setter로 접근해서 애플리케이션의 곳곳에서 수정하는 로직들이 여기 저기 숨어서 찾을 수 없는 경우가 있다.e.g.\npublic void encodeEmail(Member member){\r\n    member.setEmail(Base64.getEncoder().encodeToString(member.getEmail().getBytes()));\r\n}\r\n\r\npublic void addOAuth2PrefixVendor(Member member, String vendor){\r\n    final String email = new StringBuilder(\"###OAuth2###\").append(vendor)\r\n            .append(\"###\").append(member.getEmail())\r\n            .toString();\r\n\r\n    member.setEmail(email);\r\n}\r\n\r\n@Test\r\npublic void SETTER_TEST(){\r\n    final Member member = new Member();\r\n    member.setEmail(\"johndoe@gmail.com\");\r\n\r\n    encodeEmail(member); // 1)\r\n\r\n    // 메서드 내부에서 EMAIL 을 수정하는지 알 수 없다.\r\n    addOAuth2PrefixVendor(member, \"GOOGLE\"); // 2)\r\n\r\n    member.setEmail(\"안녕하세요\"); // 3)\r\n}\n위의 코드에서는 Member 객체를 생성한 후에 객체 외부에서 email 필드를 수정하는 부분이 총 4번 호출되었다.1)  Base64 로 Email 을 인코딩한다\n하지만, Member 객체의 email 을 수정한다는 사실은 파악하기 쉽지 않다.\nMember 객체의 email 을 수정하는지 체크하기 위해 encodeEmail(Member member) 메서드의 내부 구현을 한번 더 체크해봐야 한다.\n2) OAuth2 방식으로 유입된 사용자임을 구분하기위한 처리를 한다\n2) 의 코드 역시 메서드 내부에서 Member 객체의 필드를 수정하는지는 명확하게 알 수 없다.\n메서드 내부를 체크해봐야 한다.\n3) 모두 수정해두고 Member 객체의 외부에서 email 필드를 수정중이다\n이미 생성된 객체의 email 필드를 직접 수정하고 있다.\n이미 생성된 객체에 setter 를 사용하는 로직들은 아래의 문제가 있지 않을까 싶다.\n특정 필드를 어디에서 수정하는지 연관된 부분들을 일일이 이잡듯이 뒤져서 찾아내야 한다.\n코드가 방대해지면, 막상 영향이 가는 부분이 어디에서 호출하는 setter 인지 알수 없어지기에 고치기 쉽지 않은 소프트웨어가 된다.\n이미 생성된 객체에 대해 set 을 하는지, 새로 생성한 객체에 대해 set 을 하는지도 일일이 callstack 을 일일이 그려가며 체크해야 한다.\n여기에 더해 동시성/병렬성 환경에서도 문제가 된다. 생성된 객체의 외부가 멀티스레드를 사용하고 있고, 객체의 외부에서 setter를 호출하고 있을 때 setter 로 인해 객체 내의 데이터가 모호해지는 것을 방지할 수 없게 된다.\ne.g.\npublic void SomeTest{\r\n    // ...\r\n\r\n    private final ExecutorService executorService = Executors.newFixedThreadPool(2);\r\n\r\n    public void asyncEncodeEmail(Member member){\r\n        executorService.submit(() -> {\r\n            member.setEmail(Base64.getEncoder().encodeToString(member.getEmail().getBytes()));\r\n        });\r\n    }\r\n\r\n    @Test\r\n    public void ASYNC_ENCODE_EMAIL_TEST(){\r\n        Member member = new Member();\r\n        member.setEmail(\"abc@gmail.com\");\r\n\r\n        for(int i=0; i<100; i++){\r\n            member.setEmail(\"111@GMAIL.COM\");\r\n            asyncEncodeEmail(member);\r\n            System.out.println(\">>> (1) \" + member.getEmail());\r\n\r\n            member.setEmail(\"abc@gmail.com\");\r\n            asyncEncodeEmail(member);\r\n            System.out.println(\">>> (2) \" + member.getEmail());\r\n        }\r\n    }\r\n\r\n    @AfterEach\r\n    public void destroy(){\r\n        executorService.shutdownNow();\r\n    }\r\n}\n위 코드는 아래의 결과를 낸다.\n>>> (1) 111@GMAIL.COM\r\n>>> (2) abc@gmail.com\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) MTExQEdNQUlMLkNPTQ==\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) abc@gmail.com\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) abc@gmail.com\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) abc@gmail.com\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) abc@gmail.com\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) abc@gmail.com\r\n>>> (1) 111@GMAIL.COM\r\n>>> (2) MTExQEdNQUlMLkNPTQ==\r\n\r\n// ...\r\n어떤 케이스에는 asyncEncodeEmail 로 BASE64 인코딩한 결과가 email 필드에 저장되고, 어떤 케이스에는 BASE64 로 인코딩하지 않은 결과가 email 필드에 저장된다. 멀티스레드 코드에서 setter 를 사용하게되어 정확한 동작을 보장하기 어렵게 되었다.여러가지 해결책이 있겠지만, setter 를 써야할 것 같은 레거시 코드를 개선하는 대표적인 해결책은 아래의 방법들이 있지 않을까 싶다.","2-tostring-양방향-순환-참조-문제#2) @ToString 양방향 순환 참조 문제":"JPA 에서만 문제되는 것만은 아니다. 객체 내에 List<다른객체> 를 바인딩하는 필드가 있을 때 두 객체 모두 @Data 또는 @ToString 을 포함하고 있다면, 롬복의 @ToString의 양방향 순환참조 문제가 발생한다. 양방향 순환참조가 발생하면 toStringd 을 무한으로 생성하다보니 StackOverflowError 가 발생한다.간단한 내용이기에 예제만 정리해봤다.Member.java\n@NoArgsConstructor\r\n@Data\r\n@Entity\r\npublic class Member {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n    private String email;\r\n    private String name;\r\n\r\n    @ManyToOne(fetch = FetchType.LAZY)\r\n    @JoinColumn(name = \"dept_id\")\r\n    private Department department;\r\n}\nDepartment.java\n@Entity\r\n@Table\r\n@Data\r\npublic class Department {\r\n    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    private String deptName;\r\n\r\n    @OneToMany(mappedBy = \"department\")\r\n    private List<Member> members = new ArrayList<>();\r\n}\n두 객체간의 참조 관계가 위와 같다고 해보자. 이제 테스트코드다.\npublic class ToStringTest {\r\n\r\n    @Test\r\n    public void 양방향_순환_참조_TEST(){\r\n        final Member member = new Member();\r\n        member.setName(\"abc\");\r\n        member.setEmail(\"abc@gmail.com\");\r\n\r\n        Department deptTrader = new Department();\r\n        member.setDepartment(deptTrader);\r\n\r\n        List<Member> members = new ArrayList<>();\r\n        members.add(member);\r\n        deptTrader.setMembers(members);\r\n\r\n        Assertions.assertThatThrownBy(\r\n            () -> System.out.println(member)\r\n        ).isInstanceOf(StackOverflowError.class);\r\n    }\r\n}\nStackOverflowError 가 발생한다. 양방향 순환 참조 문제가 발생하기 때문이다.","3-equalsandhashcode-로-인해-갈수록-무거워지는-코드#3) @EqualsAndHashCode 로 인해 갈수록 무거워지는 코드":"build/classes/java/main/[패키지경로]/Member.java 를 열어보면 아래와 같이 equals() 메서드가 생성되어 있다.\n롬복이 적용된 코드는 프로젝트 내의 build/classes/java/... 내의 .class 파일을 열어보면 확인가능하다.\n@Entity\r\npublic class Member {\r\n    // ...\r\n\r\n    public boolean equals(final Object o) {\r\n        if (o == this) {\r\n            return true;\r\n        } else if (!(o instanceof Member)) {\r\n            return false;\r\n        } else {\r\n            Member other = (Member)o;\r\n            if (!other.canEqual(this)) {\r\n                return false;\r\n            } else {\r\n                label59: {\r\n                    Object this$id = this.getId();\r\n                    Object other$id = other.getId();\r\n                    if (this$id == null) {\r\n                        if (other$id == null) {\r\n                            break label59;\r\n                        }\r\n                    } else if (this$id.equals(other$id)) {\r\n                        break label59;\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                Object this$email = this.getEmail();\r\n                Object other$email = other.getEmail();\r\n                if (this$email == null) {\r\n                    if (other$email != null) {\r\n                        return false;\r\n                    }\r\n                } else if (!this$email.equals(other$email)) {\r\n                    return false;\r\n                }\r\n\r\n                Object this$name = this.getName();\r\n                Object other$name = other.getName();\r\n                if (this$name == null) {\r\n                    if (other$name != null) {\r\n                        return false;\r\n                    }\r\n                } else if (!this$name.equals(other$name)) {\r\n                    return false;\r\n                }\r\n\r\n                Object this$department = this.getDepartment();\r\n                Object other$department = other.getDepartment();\r\n                if (this$department == null) {\r\n                    if (other$department != null) {\r\n                        return false;\r\n                    }\r\n                } else if (!this$department.equals(other$department)) {\r\n                    return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n}\n만약 불필요한 필드에 대해 equals, hashcode를 생성하는 것을 방지하려면 아래와 같이 exclude 해주면 된다.\n@EqualsAndHashCode(exclude = {\"name\", \"department\"})\r\npublic class Member{\r\n    // ...\r\n}\nMember 클래스의 필드는 id, email, name, department 뿐인데, equals 로 생성된 구문은 꽤 많다. Member 클래스의 동치성 비교는 id, email 정도만해도 비교가 충분해보인다.이 외에도 hashCode() 역시 불필요한 코드에 대해 수행하고 있다.수없이 많은 equals(), hashcode() 를 무방비로 만들어서 무겁게 만들지 않으려면, 가급적  @Data 어노테이션을 사용하는 것 만큼은 자제하자."}},"/lombok-effective-how-to/builder-object-creation-builder-variation":{"title":"Builder Object Creation Builder Variation","data":{"객체-생성-빌더를-용도별로-구별하자#객체 생성 빌더를 용도별로 구별하자":"빌더 내에 경우에 따라 멤버필드를 서로 다르게 구성해야 하는 경우가 있다.\n이런 경우를 대비해 빌더는 용도별로 구별해서 사용하자.","쓰임에-따라-데이터의-바인딩이-달라질때#쓰임에 따라 데이터의 바인딩이 달라질때":"생성자는 이름을 부여해서 서로 다른 용도의 생성자로 분류할 수 없다. 이런 이유로 생성자를 오버로딩하거나, 계층적 생성자를 사용하기도 한다. 또는 정적 팩터리 메서드로 분류해두기도 한다.정적 팩터리 메서드로 분류한다고 하더라도 그 많은 인자들의 경우의 수를 감당할 수 없기에 정적 팩터리 메서드의 내부는 빌더 패턴을 통해 객체를 생성하게 되는 경우가 많을것 같다.오늘 예제는 고객이 어떤 주문을 했을 때 환불을 하는 경우에 대한 예제다.\n고객이 환불하려는 주문이 무통장입금으로 주문한 주문일 경우\n고객이 환불하려는 주문이 신용카드로 주문한 주문일 경우","refund-객체-생성#Refund 객체 생성":"Refund 객체는 아래와 같이 무통장입금 주문인지, 신용카드입금 주문인지에 따라 서로 다른 builder 메서드에서 객체 생성을 각각 다르게 하고 유효성 체크 역시 빌더 메서드마다 서로 다르게 수행되게끔 했다.Refund.java\n@Getter\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\n@Entity\r\n@Table(name = \"refund\")\r\npublic class Refund {\r\n\r\n    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @Embedded\r\n    private Account account;\r\n\r\n    @Embedded\r\n    private CreditCard creditCard;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"order_id\", nullable = false)\r\n    private Order order;\r\n\r\n    // 무통장입금으로 환불\r\n    @Builder(builderClassName = \"ByAccountBuilder\", builderMethodName = \"byAccountBuilder\")\r\n    public Refund(Account account, Order order) {\r\n        Assert.notNull(account, \"계좌번호는 비어있을 수 없습니다.\");\r\n        Assert.notNull(order, \"주문은 비어있을 수 없습니다.\");\r\n        this.account = account;\r\n        this.order = order;\r\n    }\r\n\r\n    // 신용카드로 환불\r\n    @Builder(builderClassName = \"ByCreditCardBuilder\", builderMethodName = \"byCreditCardBuilder\")\r\n    public Refund(CreditCard creditCard, Order order) {\r\n        Assert.notNull(creditCard, \"신용카드는 비어있을 수 없습니다.\");\r\n        Assert.notNull(order, \"주문은 비어있을 수 없습니다.\");\r\n        this.creditCard = creditCard;\r\n        this.order = order;\r\n    }\r\n}\n무통장 입금으로 환불할지, 신용카드로 환불할지 여부에 따라 빌더 메서드를 다르게 정의했다.이제 테스트 코드를 작성해보자.","무통장입금-주문-건-환불객체-생성-테스트#무통장입금 주문 건 환불객체 생성 테스트":"먼저 무통장 입금에 대한 환불 객체 생성 테스트다.\n@Test\r\npublic void 환불테스트__무통장입금(){\r\n    Refund refund = Refund.byAccountBuilder()\r\n            .account(account)\r\n            .order(order)\r\n            .build();\r\n\r\n    assertThat(refund.getAccount()).isEqualTo(account);\r\n    assertThat(refund.getOrder()).isEqualTo(order);\r\n}\r\n\r\n@Test\r\npublic void 환불테스트__환불계좌가_null_일경우_IllegalArgumentException이_발생해야_한다(){\r\n    Assertions.assertThatThrownBy(()->{\r\n        Refund.byAccountBuilder()\r\n                .account(null)\r\n                .order(order)\r\n                .build();\r\n    }).isInstanceOf(IllegalArgumentException.class);\r\n}\n무통장입금의 경우 환불계좌 정보가 비어있으면 안되는데, 이와 관련해서 올바르게 Exception 을 던지고 있는 것을 확인 가능하다.","신용카드-주문-건-환불객체-생성-테스트#신용카드 주문 건 환불객체 생성 테스트":"이번에는 신용카드 주문에 대한 환불 객체 생성 테스트다.\n@Test\r\npublic void 환불테스트__신용카드(){\r\n    Refund refund = Refund.byCreditCardBuilder()\r\n            .creditCard(creditCard)\r\n            .order(order)\r\n            .build();\r\n\r\n    assertThat(refund.getCreditCard()).isEqualTo(creditCard);\r\n    assertThat(refund.getOrder()).isEqualTo(order);\r\n}\r\n\r\n@Test\r\npublic void 환불테스트__환불하려는_신용카드가_null_인경우_IllegalArgumentException이_발생해야_한다(){\r\n    Assertions.assertThatThrownBy(()->{\r\n        Refund.byCreditCardBuilder()\r\n                .creditCard(null)\r\n                .order(order)\r\n                .build();\r\n    }).isInstanceOf(IllegalArgumentException.class);\r\n}\n신용카드 주문의 경우 신용카드 객체가 없으면 환불 객체가 환불할 수 없도록 IllegalArgumentException 을 올바로 던지고 있다.","전체-테스트-코드#전체 테스트 코드":"테스트 코드 전체를 코드로 남겨뒀다.\npackage io.study.lombok.lombok_howto.lomok_data;\r\n\r\nimport io.study.lombok.lombok_howto.address.Address;\r\nimport io.study.lombok.lombok_howto.order.Order;\r\nimport io.study.lombok.lombok_howto.payment.Account;\r\nimport io.study.lombok.lombok_howto.payment.CreditCard;\r\nimport io.study.lombok.lombok_howto.refund.Refund;\r\nimport org.assertj.core.api.Assertions;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport static org.assertj.core.api.Assertions.assertThat;\r\n\r\npublic class MultipleBuilderTest {\r\n\r\n    private Account account;\r\n    private CreditCard creditCard;\r\n    private Address address;\r\n\r\n    private Order order;\r\n\r\n    @BeforeEach\r\n    public void init(){\r\n        account = Account.defaultBuilder()\r\n                .accountNumber(\"111111\")\r\n                .accountHolder(\"Warren Buffet\")\r\n                .bankName(\"신한은행\")\r\n                .build();\r\n\r\n        creditCard = CreditCard.defaultBuilder()\r\n                .creditHolder(\"Warren Buffet\")\r\n                .creditNumber(\"99999999\")\r\n                .build();\r\n\r\n        address = Address.defaultBuilder()\r\n                .address1(\"경기도 성남시 분당구 판교로 777777\")\r\n                .address2(\"신한은행빌딩\")\r\n                .zip(\"1111111\")\r\n                .build();\r\n\r\n        order = Order.defaultBuilder()\r\n                .address(address)\r\n                .build();\r\n    }\r\n\r\n    @Test\r\n    public void 환불테스트__무통장입금(){\r\n        Refund refund = Refund.byAccountBuilder()\r\n                .account(account)\r\n                .order(order)\r\n                .build();\r\n\r\n        assertThat(refund.getAccount()).isEqualTo(account);\r\n        assertThat(refund.getOrder()).isEqualTo(order);\r\n    }\r\n\r\n    @Test\r\n    public void 환불테스트__환불계좌가_null_일경우_IllegalArgumentException이_발생해야_한다(){\r\n        Assertions.assertThatThrownBy(()->{\r\n            Refund.byAccountBuilder()\r\n                    .account(null)\r\n                    .order(order)\r\n                    .build();\r\n        }).isInstanceOf(IllegalArgumentException.class);\r\n    }\r\n\r\n    @Test\r\n    public void 환불테스트__신용카드(){\r\n        Refund refund = Refund.byCreditCardBuilder()\r\n                .creditCard(creditCard)\r\n                .order(order)\r\n                .build();\r\n\r\n        assertThat(refund.getCreditCard()).isEqualTo(creditCard);\r\n        assertThat(refund.getOrder()).isEqualTo(order);\r\n    }\r\n\r\n    @Test\r\n    public void 환불테스트__환불하려는_신용카드가_null_인경우_IllegalArgumentException이_발생해야_한다(){\r\n        Assertions.assertThatThrownBy(()->{\r\n            Refund.byCreditCardBuilder()\r\n                    .creditCard(null)\r\n                    .order(order)\r\n                    .build();\r\n        }).isInstanceOf(IllegalArgumentException.class);\r\n    }\r\n\r\n}","나머지-참고용도-소스코드#나머지 참고용도 소스코드":"깃허브 링크\nOrder.java\n@Getter\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\n@Entity\r\n@Table(name = \"orders\")\r\npublic class Order {\r\n    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @Embedded\r\n    private Address address;\r\n\r\n    @Builder(builderMethodName = \"defaultBuilder\")\r\n    public Order(Address address) {\r\n        Assert.notNull(address, \"주소는 비어있을 수 없습니다.\");\r\n        this.address = address;\r\n    }\r\n}\nAddress.java\npackage io.study.lombok.lombok_howto.address;\r\n\r\nimport jakarta.persistence.Embeddable;\r\nimport lombok.AccessLevel;\r\nimport lombok.Builder;\r\nimport lombok.Getter;\r\nimport lombok.NoArgsConstructor;\r\nimport org.springframework.util.Assert;\r\n\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\n@Getter\r\n@Embeddable\r\npublic class Address {\r\n\r\n    private String address1;\r\n\r\n    private String address2;\r\n\r\n    private String zip;\r\n\r\n    @Builder(builderMethodName = \"defaultBuilder\")\r\n    public Address(String address1, String address2, String zip) {\r\n        Assert.hasText(address1, \"시/군/구 건물번호 는 비어있을수 없습니다.\");\r\n        Assert.hasText(address2, \"상세 주소는 비어있을 수 없습니다.\");\r\n        Assert.hasText(zip, \"우편번호는 비어있을 수 없습니다.\");\r\n\r\n        this.address1 = address1;\r\n        this.address2 = address2;\r\n        this.zip = zip;\r\n    }\r\n\r\n}\nAccount.java\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\n@Getter\r\n@Embeddable\r\npublic class Account {\r\n\r\n    @Column(name = \"bank_name\", nullable = false)\r\n    private String bankName;\r\n\r\n    @Column(name = \"account_number\", nullable = false)\r\n    private String accountNumber;\r\n\r\n    @Column(name = \"account_holder\", nullable = false)\r\n    private String accountHolder;\r\n\r\n    @Builder(builderMethodName = \"defaultBuilder\")\r\n    public Account(String bankName, String accountNumber, String accountHolder) {\r\n        Assert.hasText(bankName, \"계좌명은 비어있으면 안됩니다.\");\r\n        Assert.hasText(accountNumber, \"계좌번호는 비어있으면 안됩니다.\");\r\n        Assert.hasText(accountHolder, \"예금주는 비어있으면 안됩니다.\");\r\n        this.bankName = bankName;\r\n        this.accountNumber = accountNumber;\r\n        this.accountHolder = accountHolder;\r\n    }\r\n}\nCreditCard.java\npackage io.study.lombok.lombok_howto.payment;\r\n\r\nimport jakarta.persistence.Column;\r\nimport jakarta.persistence.Embeddable;\r\nimport lombok.AccessLevel;\r\nimport lombok.Builder;\r\nimport lombok.Getter;\r\nimport lombok.NoArgsConstructor;\r\nimport org.springframework.util.Assert;\r\n\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\n@Getter\r\n@Embeddable\r\npublic class CreditCard {\r\n\r\n    @Column(name = \"credit_number\", nullable = false)\r\n    private String creditNumber;\r\n\r\n    @Column(name = \"credit_holder\", nullable = false)\r\n    private String creditHolder;\r\n\r\n    @Builder(builderMethodName = \"defaultBuilder\")\r\n    public CreditCard(String creditNumber, String creditHolder) {\r\n        Assert.hasText(creditNumber, \"신용카드 번호는 비어있을수 없습니다.\");\r\n        Assert.hasText(creditHolder, \"신용카드 소유자는 비어있을수 없습니다.\");\r\n        this.creditNumber = creditNumber;\r\n        this.creditHolder = creditHolder;\r\n    }\r\n}"}},"/java-features/java-21":{"title":"Java 21","data":{"java-21#Java 21":"정리 예정!!"}},"/lombok-effective-how-to":{"title":"Lombok Effective How To","data":{"롬복-효율적으로-쓰자#롬복, 효율적으로 쓰자":"@Data 애노테이션은 가급적 사용을 피하자\nBuilder - 객체 생성시 유효성 체크는 철저히\nBuilder - 객체 생성 빌더를 용도별로 구별하자"}},"/lombok-effective-how-to/builder-object-creation-static-factory-method":{"title":"Builder Object Creation Static Factory Method","data":{"빌더를-통해-객체생성은-정적-팩토리-메서드로#빌더를 통해 객체생성은 정적 팩토리 메서드로":""}},"/object":{"title":"Object","data":{"":"Object 의 주요 내용들을 요약\n참고도서\n오브젝트"}},"/object/3-cowork-responsibility-role":{"title":"3 Cowork Responsibility Role","data":{"3-협력-책임-역할#3. 협력, 책임, 역할":"","참고자료#참고자료":"오브젝트","협력-책임-역할-이란#협력, 책임, 역할 이란?":"","협력#협력":"어떤 객체가 다른 객체에게 무엇인가를 요청하는 것을 협력이라고 한다.\r\n객체 상의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.(Wirfs-Brock03)\r\n협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다.\r\n협력은 책임을 이끌어내고, 책임이 협력에 참여할 객체를 결정한다.\ne.g.\nScreening 은 Movie 객체에 메시지를 전송한다.\nScreening 은 Movie 객체와 협력하고 있다.","책임#책임":"협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다.\r\n책임은 객체가 어떤 행동을 해야할 지를 사람의 화법으로 표현한 것이다.\n참고) 책임할당, 책임주도설계, 책임과 협력","역할#역할":"역할은 책임의 집합을 의미한다.\r\n여러 종류의 책임은 하나의 역할로 추상화할 수 있다.\r\n어떤 책임(메시지)가 여러 종류의 객체에서 사용된다면, 이 여러 종류의 책임 객체들을 역할로 분류한다.\r\n책임은 구체(concrete) 개념이고, 역할은 추상(abstract) 개념이다.\r\n여러 종류의 책임에서 공통점을 찾아내서 역할이라는 추상클래스/인터페이스로 분류할 수 있다.\ne.g. 책임\n금액할인(AmountDiscountPolicy), 비율할인(PercentDiscountPolicy), 무할인(NoneDiscountPolicy) 객체들에 공통적으로 존재하는 calculateDiscountAmount() 메서드\ne.g. 역할\nDiscountPolicy\nAmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체에 대해 DiscountPolicy 라는 이름의 하나의 역할 클래스로 정의한다.","협력-1#협력":"","협력-설계-시-거치는-주요-원칙#협력 설계 시 거치는 주요 원칙":"1) 객체는 자신의 일을 스스로 처리할 수 있는 자율적인 존재여야 한다.\nMovie 객체는 자율적인 존재가 되기 위해서는 요금 계산을 스스로 처리할 수 있어야 한다.\n2) 협력이 설계를 위한 문맥을 제공한다.\n상태, 행동을 정의하면서 협력관계가 도출되고 객체를 설계하는 데에 있어서 필요한 문맥(Context)가 도출된다.\n3) 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.\r\ne.g. Screening 이 Movie, DiscountPolicy, Screening 같은 캡슐화된 객체를 통해 Screening 의 역할을 수행하고, 캡슐화 된 Movie, DiscountPolicy, Screening 역시 외부에 영향없이 자율적으로 역할을 수행","1-객체는-자신의-일을-스스로-처리할-수-있는-자율적인-존재여야-한다#1) 객체는 자신의 일을 스스로 처리할 수 있는 자율적인 존재여야 한다.":"Movie 객체는 영화 요금 계산을 자율적으로 처리할 수 있다.\r\n자신이 할 수 없는 할인요금 계산은 DiscountPolicy 에 위임해 할인 금액을 얻어온다.\r\n다른 코드의 상수 코드나 상태에 종속적이지 않다. 필요한 다른 계산, 처리는 객체에 위임해서 얻어오고 자신의 역할을 한다.\npublic class Movie{\r\n\tprivate Money fee;\t// 생성자 주입\r\n\tprivate DiscountPolicy discountPolicy; \t// 생성자 주입\r\n\r\n\t// ...\r\n\r\n\tpublic Money calculateMovieFee(Screening screening){\r\n\t\treturn fee.minus(discountPolicy.calculateDiscountAmount(screening));\r\n\t}\r\n}","2-협력이-설계를-위한-문맥을-제공한다-상태-행동-협력관계#2) 협력이 설계를 위한 문맥을 제공한다. (상태, 행동, 협력관계)":"상태, 행동을 정의하면서 협력관계가 도출되고 객체를 설계하는 데에 있어서 필요한 문맥(Context)가 도출된다.\n상태란 객체가 어떤 행동을 하는 데에 필요한 정보다.\r\n행동은 협력 내에서 객체가 처리할 메시지다.협력 설계시 상태, 행동을 고려해 설계를 하면 협력을 통해 행동을 하게 되고, 행동은 상태를 필요로 한다.협력관계를 통해서 객체를 설계하는 데에 있어서 필요한 문맥(Context)가 도출된다.","3-객체를-자율적으로-만드는-가장-기본적인-방법은-내부-구현을-캡슐화하는-것이다#3) 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.":"자율적인 객체를 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다. 이렇게 캡슐화를 통해 변경으로 인한 파급효과(Side Effect)를 줄일 수 있다.\npublic class Movie{\r\n\tprivate Money fee; // 생성자 주입\r\n\tprivate DiscountPolicy discountPolicy; // 생성자 주입\r\n\r\n\t// ...\r\n\r\n\tpublic Money calculateMovieFee(Screening screening){\r\n\t\treturn fee.minus(discountPolilcy.calculateDiscountAmount(screening));\r\n\t}\r\n}","책임-1#책임":"협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다.\r\n책임은 객체가 어떤 행동을 해야할 지를 사람의 화법으로 표현한 것이다.\r\n“책임을 수행한다.” 는 말은 “메시지를 전송한다.” 라는 말로도 표현된다.\n참고) 책임할당, 책임주도설계, 책임과 협력","책임할당#책임할당":"책임을 할당하는 것은 메시지의 이름을 결정하는 것과 같다.책임할당 과정에서는 아래의 두 과정을 끊임없이 반복한다.\n메시지의 이름을 결정한다. (책임에 대한 이름을 짓는다.)\n메시지를 처리할 객체를 결정한다. (책임을 수행할 객체를 선택)","책임주도-설계-rdd-responsibility-driven-design#책임주도 설계 (RDD, Responsibility-Driven Design)":"책임을 찾고 책임을 수행할 적절한 객체를 찾아서 책임을 할당하는 방식으로 협력을 설계하는 방식을 책임주도 설계(Responsibility-Driven Design, RDD) 라고 부른다.\ne.g. Movie 객체는 자율적인 존재가 되기 위해서는 요금 계산을 스스로 처리할 수 있어야 한다.\n책임주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있게 한다.\n처음부터 객체를 구현해나가면서 리팩토링하는 것이 아니라 기능의 리스트업을 통해 세부적인 메시지를 정의하고\r\n이것을 수행할 객체를 선택하는 과정을 거친다. 이렇게 하면 결국 책임을 기반으로 결정을 하게 된다.","책임할당할-객체-선택-시-주요-원칙#책임할당할 객체 선택 시 주요 원칙":"1) 메시지가 객체를 결정한다.\n메시지가 객체를 결정하게 해야 한다. 객체가 메시지를 결정하게 하는 것이 아니다.\n메시지가 객체를 결정하게끔 하면, 아래의 두 장점을 얻는다.\n객체가 최소한의 인터페이스를 갖게된다.\n추상적인 인터페이스를 가질 수 있게 된다.\n2) 행동이 상태를 결정한다. 행동이 객체의 책임이 되어야 한다.\n객체는 협력에 필요한 행동을 제공해야 한다. 객체의 상태가 아닌 행동이 중요하다. (객체의 상태는 행동이 결정되어야 상태가 결정된다.)\n객체의 행동이 아닌 상태에 초점을 맞출 경우 캡슐화가 저해되는 결과를 낳는다.\n행동이 아닌 상태에 초점을 맞추는 실수(상태를 먼저 결정하고 행동을 결정)를 유의해야 한다.\n객체의 상태에 초점을 맞춰 구현을 하면 내부 구현이 퍼블릭 인터페이스로 노출된다. 이때 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경된다. 이러면 결국 클라이언트 계층까지 변경의 영향이 전파된다.\n행동이 상태를 결정하지 않고 상태를 먼저 정의후 행동을 정의하는 방식은 데이터 주도 설계(Data Driven Design)라고 부른다. (레베카 워스트브룩)","책임주도-설계-rdd-responsibility-driven-design-를-하는-과정#책임주도 설계 (RDD, Responsibility-Driven Design) 를 하는 과정":"시스템의 책임을 파악한다. (시스템의 책임은 시스템이 사용자에게 제공해야 하는 기능을 의미)\n시스템의 책임을 더 작은 책임으로 분할한다.\n분할된 책임을 수행할 수 있는 적절한 객체/역할을 찾아서 할당한다.\n객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이것을 책임질 적절한 객체/역할을 찾는다.\n해당 객체 또는 역할에게 책임을 할당하는 것으로 두 객체가 협력하게 한다.","책임과-협력#책임과 협력":"협력 관계 속에서 책임을 도출한다.\r\n책임은 책임을 수행할 객체를 선택해서 메시지를 어떤 객체에서 수행할지를 결정한다.\r\n이렇게 결정한 객체에 대한 책임(메서드)은 다른 객체와 협력관계를 갖는다.\r\n책임을 통해 객체가 행동을 하는데, 행동은 다른 객체와 협력관계를 맺는다. 따라서 협력과 책임은 서로 연관된 개념이다.","역할-1#역할":"역할은 책임의 집합을 의미한다.\r\n여러 종류의 책임은 하나의 역할로 추상화할 수 있다.\r\n어떤 책임(메시지)가 여러 종류의 객체에서 사용된다면, 이 여러 종류의 책임 객체들을 역할로 분류한다.\r\n책임은 구체(concrete) 개념이고, 역할은 추상(abstract) 개념이다.\r\n여러 종류의 책임에서 공통점을 찾아내서 역할이라는 추상클래스/인터페이스로 분류할 수 있다.\ne.g. 책임\n금액할인(AmountDiscountPolicy), 비율할인(PercentDiscountPolicy), 무할인(NoneDiscountPolicy) 객체들에 공통적으로 존재하는 calculateDiscountAmount()\ne.g. 역할\nDiscountPolicy 와 같은 여러 책임들을 추상화할 수 있는 추상화 클래스를 역할 클래스라고 한다.\nAmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체에 대해 DiscountPolicy 라는 이름의 하나의 역할 클래스로 정의한다.","역할과-추상화#역할과 추상화":"역할은 추상화를 이용해 공통의 책임ㅇ르 바탕으로 객체의 종류를 숨긴다.\r\n역할을 사용하면 아래의 두 장점을 갖게 된다. (2장. 추상화 참고)\n중요한 정책을 추상화해서 상위 수준에서 단순화할 수 있다.\n세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다.\ne.g. 금액할인 정책, 비율할인 정책을 순번/기간 조건과 조합해 다양한 방식의 요금 규칙을 설정할 수 있게 된다.\n설계가 조금 더 유연해진다.\n다양한 종류의 객체를 끼워넣을 수 있도록 하나의 추상화된 클래스인 DiscountPolicy 를 도입했다는 사실을 기억하자.","책임에서부터-역할로-분류해가는-과정#책임에서부터 역할로 분류해가는 과정":"책임 정의\r\n객체가 수행하는 행동을 메시지로 정의한다. 이렇게 객체가 수행하는 메시지를 책임 이라고 부른다.\n역할 도출\r\n특정 메시지는 특정 상황(e.g. 할인가격 계산)속 에서 특정 객체들이 같은 이름의 메시지를 갖는 경우가 있다.\r\n이렇게 같은 이름의 메시지가 여러 객체에 존재할 때 이것을 공통된 객체 내의 메시지로 추상화를 하는데, 이것을 역할이라고 한다.\ne.g. 책임\n금액할인(AmountDiscountPolicy) 객체의 calculateDiscountAmount()\n비율할인(PercentDiscountPolicy) 객체의 calculateDiscountAmount()\n무할인(NoneDiscountPolicy) 객체의 calculateDiscountAmount()\ne.g. 역할\nDiscountPolicy 로 추상화\nAmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체에 대해 DiscountPolicy 라는 이름의 하나의 역할 클래스로 정의하고 DiscountPolicy 클래스는 추상 메서드로 calculateDiscountAmount() 를 갖는다.\ne.g. 그림으로 정리해보면 아래와 같다.","eg-역할에-책임을-할당한-코드#e.g. 역할에 책임을 할당한 코드":"DiscountPolicy 는 AmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체를 대체할 수 있는 추상화 클래스다.\npublic class Movie{\r\n\t\r\n\t// ...\r\n\r\n\tprivate DiscountPolicy discountPolicy; // 생성자 주입\r\n\r\n\tpublic Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy){\r\n\t\t// ...\r\n\t\tthis.discountPolicy = discountPolicy;\r\n\t}\r\n\r\n\t// ...\r\n\r\n\tpublic Money calculateMovieFee(Screening screening){\r\n\t\treturn fee.minus(\r\n\t\t\tdiscountPolicy.calculateDiscountAmount(screening);\r\n\t\t);\r\n\t}\r\n}"}},"/lombok-effective-how-to/builder-object-creation-validation-check":{"title":"Builder Object Creation Validation Check","data":{"객체-생성시-유효성-체크는-철저히#객체 생성시 유효성 체크는 철저히":"@Builder 에 비어있는 값이 있을 경우를 체크하자\n빌더 구문 내에서의 필수값 체크는 확실하게 하자","builder-패턴의-허점#Builder 패턴의 허점":"빌더는 객체 생성을 편리하고 안전하게 할 수 있다는 점은 장점이다. 다만, 빌더 패턴을 통해 객체 생성시 누락될 수 있는 필드들에 대한 유효성 체크를 확실하게 해야 한다는 점도 간과하면 안된다.예를 들어 주식 Ticker 에 대한 클래스 Stock 이 있을 때 주식 종목에 대한 국가 코드는 없으면 안된다. 그리고 ticker 명, 종목 영문명, 종목명 은 비어있으면 안된다.주식 Ticker 에 대한 클래스인 Stock 클래스 예제를 통해서 나쁜 예와 좋은 예를 확인해보자.","나쁜-예--stock1java#나쁜 예 : Stock1.java":"@Getter\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\npublic class Stock1 {\r\n\r\n    private String ticker;\r\n    private String companyNameEn;\r\n    private String companyName;\r\n    private String sector;\r\n    private String countryCode;\r\n\r\n    @Builder(builderMethodName = \"defaultBuilder\")\r\n    public Stock1(String ticker, String companyNameEn, String companyName, String sector, String countryCode) {\r\n        this.ticker = ticker;\r\n        this.companyNameEn = companyNameEn;\r\n        this.companyName = companyName;\r\n        this.sector = sector;\r\n        this.countryCode = countryCode;\r\n    }\r\n\r\n}\n@Builder 를 이용해서 객체를 생성하는 평이한 구문이다.Stock 클래스의 필수 필드는 ticker 명, 종목 영문명, 종목명, 국가코드다.그런데 위의 @Builder가 적용된 생성자 구문은 아래의 문제점이 있다.\nticker 명이 null 인지, 비어있는지를 체크하지 않는다.\ncompanyNameEn 명이 null 인지, 비어있는지를 체크하지 않는다.\ncompanyName 명이 null 인지, 비어있는지를 체크하지 않는다.\ncountryCode 명이 null 인지, 비어있는지를 체크하지 않는다.\n테스트코드\n@Test\r\npublic void TEST_NULL_1(){\r\n    Stock1 amzn = Stock1.defaultBuilder()\r\n            .ticker(\"AMZN\")\r\n            .sector(\"SALES\")\r\n            .companyName(\"Amazon\")\r\n            .companyNameEn(\"Amazon\")\r\n            .countryCode(\" \") // 국가 코드가 비어있는 상태로 객체를 생성해보자.\r\n            .build();\r\n\r\n    assertThat(amzn.getCountryCode()).isBlank();\r\n\r\n    Stock1 meta = Stock1.defaultBuilder()\r\n            .ticker(\"META\")\r\n            .sector(\"IT SERVICE\")\r\n            .companyName(\"Meta\")\r\n            .companyNameEn(\"Meta\")\r\n            .countryCode(null) // 국가 코드를 null 로 대입했다.\r\n            .build();\r\n\r\n    assertThat(meta.getCountryCode()).isNull();\r\n}","좋은-예--stock2java#좋은 예 : Stock2.java":"위의 코드에서 객체 생성을 완전하게 하기위해 유효성체크를 하는 구문을 추가해보자.\n@Getter\r\n@NoArgsConstructor\r\npublic class Stock2 {\r\n\r\n    private String ticker;\r\n    private String companyNameEn;\r\n    private String companyName;\r\n    private String sector;\r\n    private String countryCode;\r\n\r\n    @Builder(builderMethodName = \"defaultBuilder\")\r\n    public Stock2(String ticker, String companyNameEn, String companyName, String sector, String countryCode) {\r\n        Assert.hasText(ticker, \"Ticker must not be empty.\");\r\n        Assert.hasText(companyName, \"Company name must not be empty.\");\r\n        Assert.hasText(companyNameEn, \"Company name in English must not be empty\");\r\n        Assert.hasText(countryCode, \"Country code must not be empty\");\r\n\r\n        this.ticker = ticker;\r\n        this.companyNameEn = companyNameEn;\r\n        this.companyName = companyName;\r\n        this.sector = sector;\r\n        this.countryCode = countryCode;\r\n    }\r\n}\nStock 데이터에 대한 필수 조건은 아래와 같았다.\nticker 명이 null 인지, 비어있는지를 체크하지 않는다.\ncompanyNameEn 명이 null 인지, 비어있는지를 체크하지 않는다.\ncompanyName 명이 null 인지, 비어있는지를 체크하지 않는다.\ncountryCode 명이 null 인지, 비어있는지를 체크하지 않는다.\n위의 빌더 구문에서는 위의 조건에 대한 유효성 체크를 수행하고 있다.이렇게 유효성 체크 후 예외를 발생시키는 구문을 객체 생성 구문에 작성해두면, 객체 외부에서 null 체크를 쓸데없이 안해도 된다.\n테스트코드\n@Test\r\npublic void TEST_NULL_2(){\r\n    Assertions.assertThatThrownBy(()->{\r\n        Stock2 amzn = Stock2.defaultBuilder()\r\n                .ticker(\"AMZN\")\r\n                .sector(\"SALES\")\r\n                .companyName(\"Amazon\")\r\n                .companyNameEn(\"Amazon\")\r\n                .countryCode(\" \") // 국가 코드가 비어있는 상태로 객체를 생성해보자.\r\n                .build();\r\n    }).isInstanceOf(IllegalArgumentException.class);\r\n\r\n    Assertions.assertThatThrownBy(()->{\r\n        Stock2 meta = Stock2.defaultBuilder()\r\n                .ticker(\"META\")\r\n                .sector(\"IT SERVICE\")\r\n                .companyName(\"Meta\")\r\n                .companyNameEn(\"Meta\")\r\n                .countryCode(null) // 국가 코드를 null 로 대입했다.\r\n                .build();\r\n    }).isInstanceOf(IllegalArgumentException.class);\r\n}"}},"/object/9-flexible-design":{"title":"9 Flexible Design","data":{"9-유연한-설계#9. 유연한 설계":"","참고자료#참고자료":"오브젝트","함께-생각해볼만한-자료#함께 생각해볼만한 자료":"초식 - 의존방향 생각하기","01-개방-폐쇄-법칙-open-closed-principle-ocp#01. 개방-폐쇄 법칙 (Open-Closed Principle, OCP)":"","ocpopen-closed-principle-ocp-로버트-마틴#OCP(Open-Closed Principle, OCP), 로버트 마틴":"로버트 마틴은 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나로 개방 폐쇄 원칙(Open-Closed Principle, OCP)을 고안했다.\n로버트 마틴이 이야기하는 OCP는 아래와 같다.\n소프트웨어 개체(클래스, 모듈,함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.\n개방 폐쇄 원칙 관점에서 유연한 설계라는 것은 기존의 코드를 수정하지 않고도(=수정에 닫혀있고) 애플리케이션의 동작을 확장할 수 있는 설계(=확장에는 열려있다.)를 의미한다\n개방 폐쇄 원칙을 지키는 설계를 하다보면, 결과적으로는 일반적으로 아래의 원칙을 따르게 된다.\n컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라\n추상화가 핵심이다.","컴파일-타임-의존성을-고정시키고-런타임-의존성을-변경하라#컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라.":"개방-폐쇄 원칙은 사실 런타임 의존성과 컴파일 의존성에 관한 이야기다.\n런타임 의존성은 실행 시에 협력에 참여하는 객체들 사이의 관계다.\n컴파일 타임 의존성은 코드에서 드러나는 클래스들 사이의 관계다.\n개방-폐쇄 원칙을 지키는 코드는 컴파일 타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.","eg-새로운-영화-할인-정책-추가시-ocp-원칙#e.g. 새로운 영화 할인 정책 추가시 OCP 원칙":"새로운 영화 할인 정책으로 중복할인 정책인 \"OverlappedDiscountPolicy\" 를 추가하는 예를 들어보자.\n새로운 할인 정책인 OverlappedDiscountPolicy 를 추가할 때 기존 코드를 수정하면 컴파일 의존성을 해치게 된다. 대신 DiscountPolicy 라는 타입으로 할인 정책을 주입받도록 하고, 런타임 의존성으로 OverlappedDiscountPolicy 객체를 생성해서 DiscountPolicy 에 바인딩해주면, 기존 코드(컴파일 의존성)은 수정하지 않으면서 런타임에 새로운 기능이 추가될 수 있게 된다.","추상화가-핵심이다#추상화가 핵심이다.":"개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.\r\n'추상화', '의존' 이 두 단어에 주목하자.\n추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.\n공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.\n이렇게 공통적인 부분이라는 것은 추상화를 의미한다.\n이렇게 추상화로 분류한 부분은 수정에 대해 닫혀 있어야 한다.\n이렇게 추상화를 통해 생략된 부분은 확장의 여지를 남긴다. 이렇게 확장의 여지를 남기는 것을 통해 개방-폐쇄 원칙을 가능하게 만들어준다.","변하지-않는-부분-vs-변하는-부분#변하지 않는 부분 vs 변하는 부분":"참고\nDiscountCondition\nDiscountPolicy\n(1) : 변하지 않는 부분\n아래 코드에서 할인 여부를 판단하는 로직이다.\nisSatisfiedBy(Screening) 은 어디에서든 공통으로 쓰여야 한다.\nisSatisfiedBy(Screening) 을 추상화된 클래스로 분류해 수정에 닫혀있도록 해주었다.\nPeriodCondition, SequenceCondition 클래스는 DiscountCondition 이라는 interface의 구현체(implement)다.\n(2) : 변하는 부분\n아래 코드에서 변하는 부분은 할인 요금을 계산하는 방법이다.\nDiscountPolicy 를 상속해서 생략된 부분을 오버라이딩(구체화)하면 할인 정책을 확장할 수 있게 된다.\nDiscountPolicy 를 확장하는 클래스인 AmountDiscountPolicy, PercentDiscountPolicy, NoDiscountPolicy 는 각각 getDiscountAmount(Screening) 에 대한 구현 부분이 각각 다르다.\n즉, AmountDiscountPolicy, PercentDiscountPolicy, NoDiscountPolicy 는 각각 할인 요금을 계산하는 방법이 다르다.\npackage org.eternity.movie.step01;\r\n\r\nimport org.eternity.money.Money;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic abstract class DiscountPolicy {\r\n    private List<DiscountCondition> conditions = new ArrayList<>();\r\n\r\n    public DiscountPolicy(DiscountCondition ... conditions) {\r\n        this.conditions = Arrays.asList(conditions);\r\n    }\r\n\r\n    public Money calculateDiscountAmount(Screening screening) {\r\n        for(DiscountCondition each : conditions) {\r\n\t\t\t// 변하지 않는 부분 : 할인 여부를 판단하는 로직\r\n            if (each.isSatisfiedBy(screening)) { // -- (1)\r\n                return getDiscountAmount(screening);\r\n            }\r\n        }\r\n\r\n        return screening.getMovieFee();\r\n    }\r\n\r\n\t// 변하는 부분 : 할인 요금을 계산하는 방법\r\n\t// -- (2)\r\n    abstract protected Money getDiscountAmount(Screening Screening);\r\n}","02-생성-사용-분리#02. 생성, 사용 분리":"","객체-생성과-객체-사용로직이-혼재하는-것의-문제점#객체 생성과 객체 사용로직이 혼재하는 것의 문제점":"객체 생성 역시 개방 폐쇄 원칙을 위배하게끔 한다. 객체 생성을 하는 로직은 수정사항 발생시 동작의 추가 변경을 발생시킨다.\r\n특히 클래스 내에서 다른 객체를 생성하는 코드는 해당 객체에 대한 지식을 요구하기에 결합도를 높이는 요인이 되기도 한다.이렇게 객체를 생성하는 부분을 분리하는 보편적인 방법은 객체 생성에 대한 책임을 클라이언트 역할을 하는 별도의 클래스 내의 메서드로 따로 옮기는 것이다.","객체-생성-로직을-일반-코드에서-분리하는-일반적인-방법들#객체 생성 로직을 일반 코드에서 분리하는 일반적인 방법들":"객체 생성 로직은 아래와 같은 클래스/메서드에 따로 분리해두면, 개방/폐쇄 원칙을 지킬 수 있게 된다.\n클라이언트 역할의 클래스\nFactory 클래스\n순수한 가공물 (Pure Fabrication)","03-의존성-주입#03. 의존성 주입":"","의존성-주입#의존성 주입":"객체의 생성과 객체의 사용을 분리하고 나면 인스턴스를 사용하는 책임만 남겨지게 된다.\r\n즉, 인스턴스를 사용하는 로직만 남겨지게 된다.\r\n사용하려고 하는 인스턴스는 객체의 외부에서 생성해서 전달해줘야 사용이 가능한데, 이렇게 객체를 외부에서 생성해서 전달해주는 방식을 의존성 주입이라고 한다.\n괜히 개념이 조금 어렵게 느껴질수도 있겠다.\r\n흔히 메서드 파라미터로 원하는 객채를 명시하고 외부에서 사용시에 해당 객체에 대한 구현체를 주입하는 것도 일종의 의존성 주입이다.\r\ngetter, setter, 생성자 주입만을 떠올릴 수 있지만, 테스트가 가능한 코드를 작성하다보면 메서드의 파라미터로 객체를 지정하는 경우가 많다. 이런 경우도 의존성 주입을 하는 하나의 예다.\n이렇게 생성자 주입이든, getter/setter 주입이든, 메서드 주입이든 외부의 독립적인 객체로부터 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방식을 의존성 주입(Dependency Injection)[Fowler04]이라고 부른다.\n참고\n스프링의 의존성 주입은 프레임워크 레벨에서 Bean 을 찾아서 주입해주는 것을 의미한다.","의존성-주입은-숨겨진-의존성의-단점을-해결할-수-있다#의존성 주입은 숨겨진 의존성의 단점을 해결할 수 있다.":"의존성을 이해하기 위해 다른 코드의 내부를 읽을 필요가 없다. 따라서 캡슐화를 이룰 수 있고, 객체의 캡슐을 단단하게 보호한다.\r\n객체 생성을 위해 필요한 인자값, 객체 생성시 수행하는 객체 내부의 동작 등\n의존성과 관련된 문제를 최대한 컴파일 타임에 잡아낼 수 있다.\n필요한 의존성을 인자에 추가하지 않으면 컴파일 타임에 에러가 발생하기 때문","요약#요약":"의존성 주입이란?\r\n외부에서 의존성을 해결하고, 이것을 사용하는 객체에 주입하는 동작을 의미\n3가지 의존성 주입 방식\n생성자 주입 : 객체를 생성하는 시점에 생성자를 통해 의존성 해결\nsetter 주입 : 객체 생성 후 setter 메서드를 호출해 의존성 해결\n메서드 주입 : 메서드 실행 시 인자를 이용해 의존성 해결\ne.g. 생성자 주입\nMovie avatar = new Movie(\"아바타\",\r\n\t\t\t\t\tDuration.ofMillis(120),\r\n\t\t\t\t\tMoney.wons(10000),\r\n\t\t\t\t\tnew AmountDiscountPolicy(...)\r\n\t\t\t\t);","04-의존성-역전-dependency-inversion-principle-dip-로버트-마틴martin02#04. 의존성 역전 (Dependency Inversion Principle, DIP, 로버트 마틴)[Martin02]":"의존성 역전 원칙(로버트 마틴)\n상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.\n추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다."}},"/tdd":{"title":"Tdd","data":{"tdd#TDD":"모르겠다. 걍 시간날 때 마다 꾸준히!!!"}}}