{"/java-features/java-10":{"title":"Java 10","data":{"java-10#Java 10":"","참고자료#참고자료":"Java 10의 새로운 기능 - 성능향상\nJava 10 - var 키워드로 변수선언 (지역변수 타입추론)\nJava 10 의 새로운 기능\nhttps://www.baeldung.com/java-10-overview","요약#요약":"G1 가비지 컬렉터의 Full GC 수행시 병렬기반 동작하도록 변경\nJava 10 에서는 G1 가비지 컬렉터로 Full GC 수행 시에 병렬 기반 Mark Seep Compact 알고리즘을 사용하도록 변경. 병렬 기반이기에 Full GC 시의 정지시간을 효과적을 줄여주게 되었다.\n참고 : Java 9 에서는 G1 가비지 컬렉를 이용한 Full GC 는 싱글스레드 기반 Mark Sweep Compact 알고리즘을 사용\nAppCDS\nJDK8, JDK9 에서는 상용기능이었으나, Java 10 에서는 오픈 소스이며 공개적으로 사용 가능\nGraal 컴파일러를 JIT 컴파일러로 쓸수 있게끔 제공. Java 10 에서는 Graal 컴파일러는 실험적인 기능이기에 현존하는 JIT 컴파일러보다는 더 나은 성능을 보장하지는 않는다.\nvar 키워드 도입\nvar 키워드를 사용하면 지역변수 추론시 컴파일 타임에 변수의 타입을 추론가능해짐.\n변수의 타입을 지정하지 않고 var 키워드를 사용해 변수를 선언.\n참고 - codechacha\n불변 컬렉션관련 편의성 정적 메서드 제공\ncopyOf() : 주어진 Collection 의 수정 불가능한 복사본 반환\nCollectors.toUnmodifiable() : Stream의 collect 연산시 불변 List,Map,Set으로 수집하는 연산\nOptional 에 orElseThrow 추가\n기존 get() 메서드를 사용하는 것에 비해 비교적 권장되는 편.\n컨테이너 인식 관련 지원\nXX:UseContainerSupport\nJVM이 Docker 컨테이너에서 실행되고 있는지 인식가능해짐\nXX:ActiveProcessorCount={count}\n컨테이너 내에서 구동되는 JVM이 사용할 CPU 수를 지정\nXX:InitialRAMPercentage, XX:MaxRAMPercentage, XX:MinRAMPercentage\nJava 힙의 초기 메모리 퍼센트, 최대 퍼센트, 최소 퍼센트를 지정 가능해짐\n루트인증서\nTLS 등의 중요 Security 관련 구성요소를 OpenJDK 빌드에서 기본적으로 작동하지 않던 이슈가 있었는데\nJava 10 부터는 Oracle 의 Java SE 루트 CA 프로그램에서 루트 인증서를 오픈 소스로 제공\nOpen JDK 빌드를 개발자에게 더 매력적으로 만들고 Oracle JDK 빌드 간의 차이를 줄이기 위한 Oracle 에서의 지원내용\nCLI 변경사항\njavah 도구 제거. 대신 javac -h 사용가능. (javah 는 네이티브 메서드를 구현하는 데에 필요한 c 헤더 및 소스파일을 생성시 사용했던 도구)\npolicytool 제거\n정책 파일 생성 및 관리를 위한 UI 기반 도구\njava -Xprof 옵션 제거\n실행중인 프로그램을 프로파일링, 프로파일링 데이터를 표준 출력(stdout)으로 내보내는데 사용되던 도구\n대신 jmap 도구를 사용하면 된다.\njava.security.acl\njava.security.acl 패키지는 java.security.Policy 및 관련 클래스로 대체 됨\nforRemoval = true 로 표시\njava.security.{Cirtificate, Identity, IdentityScope, Signer} 내의 API 는 모두 forRemoval = true 로 표시\n시간 기반 릴리즈 버전 관리\nJava 10 부터 Oracle 은 Java 의 시간 기반 릴리즈로 변경\n새로운 기능 릴리즈에 대한 지원은 6개월 동안만 지속\n장기 지원 릴리즈는 LTS로 표시되며 LTS에 대한 지원은 3년. Java 11 은 LTS 릴리즈\n6개월마다 새로운 Java 릴리즈. 이를 기능릴리즈라 명명\n2018년 3월 릴리즈 : JDK 10\n2018년 9월 릴리즈 : JDK 11\n기능 리리즈에 대한 지원은 다음 릴리즈까지 6개월 동안만 지속\njava -version  시 GA 날짜가 출력에 포함\nopenjdk version \"10\" 2018-03-20"}},"/java-features/java-11":{"title":"Java 11","data":{"java-11-변경-내용들#Java 11 변경 내용들":"","참고자료#참고자료":"Java 8과 비교하여 Java 11 에서는 GC가 어떻게 변했을까?\nJava 11 New Features","요약#요약":"Java 10 까지는 상업적으로 사용할 수 있는 마지막 무료 Oracle JDK 릴리즈. Java 11 부터는 Oracle의 무료 LTS가 없다. 다만, OpenJDK 를 제공하고 있다.\nJava 9 에서부터 계속해서 디폴트 GC는 G1GC\nZGC (Z Garbage Collector) 실험적 도입\n테라바이트 규모의 매우 큰 heap 을 사용하는 애플리케이션을 위한 GC\n10ms 미만의 짧은 대기 시간이 필요한 경우에 사용\nlambda 에서 var 키워드 사용 지원 추가 (대신 @NonNull 필요)\n아래에 간단한 예제 추가(!!TODO!!)\nHttpClient 추가 (Java 9 에서는 HttpRequest, Java 11 에서는 HttpClient)\nHttp 1.1, 2 를 모두 지원\njavac 컴파일 없이 바로 java Helloworld 실행 가능해짐\n성능\n상수 Pool 지원\n테스트용도 가비지수집기(Epsilon) 제공. 메모리를 할당하지만, 가비지는 수집x, 따라서 메모리 부족 오류 테스트/시뮬레이션 할때 사용가능.\nAArch64 내장함수들 최적화, java.util.Math 의 sin,cos,log 에 대한 새로운 내장함수 구현\nString 클래스에 편의성 메서드 추가\nisBlank, lins, strip, stripLeading, stripTrailing, repeat\n테스트 코드를 추가해둘 예정\nFile 클래스에 편의성 메서드 추가\nwriteString, readString\n리스트 → 배열 변환 편의 메서드 추가 (e.g. wordList.toArray(String[]::new))\nPredicate 인터페이스에 not 메서드 추가 (negate 와 유사한 역할)\nNest Class, 중첩 클래스 액세스 개념 도입\n유니코드 10 지원, 이모지 제공, 더 많은 문자 제공\n암호화 방식관련 불안전한 것들 보완, 새로운 암호화 키 계약 지원, TLS 버전 1.3 업그레이드 관련 변경사항 (참고)\n제거된 기능\nJava EE, CORBRA\nJMC, JavaFX\nJavaFX는 JDK외부에서 벼롣의 모듈세트로 사용가능, JMC는 독립형 버전의 JMC 다운로드 후 사용가능\nNashron Javascript 엔진, Jar 파일에 대한 Pack200 압축해제"}},"/java-features":{"title":"Java Features","data":{"java-features#Java Features":""}},"/java-features/java-16":{"title":"Java 16","data":{"java-16#Java 16":"","참고자료#참고자료":"Java 8 부터 16까지의 신규기능들\nZGC - JDK 16의 새로운 기능들(gc 성능 관련)","요약#요약":"text block\nJEP 359 - Records를 정식지원 시작\n자바 15의 외부메모리 접근 인큐베이팅 2차\n자바 15에 추가된 sealed 클래스의 2차 Preview\nJEP 387 : 자바 8부터 제거된 악명높은 PermGen 대신 Metaspace 방식을 지원하기 시작.\nJEP 343 : jpackage 명령어를 통해 각 운영체제별 자바 프로그램을 설치 패키지(pkg, deb, msi 등)로 생성하는 기능이 정식으로 추가되어, 자바 프로그램을 손쉽게 배포하는 기능이 추가됨\nJEP 389 : JNI를 대신할 외부 링크 방식의 인터페이스를 인큐베이팅을 통해 시작\nJEP 347 : 자바 네이티브(JNI 등) 개발 시 C++14 규격을 지원하기 시작\nJEP 338 : Vector API. 자동병렬프로세싱을 지원하는 자동 벡터 API가 추가될 예정 (Incubator)\nJEP 390 : 값 유형의 클래스를 동기화에 사용 시 경고 메시지가 개선"}},"/java-features/java-17":{"title":"Java 17","data":{"java-17#Java 17":"","참고자료#참고자료":"JDK 17 발표 및 새로운 변화 - blogs.oracle.com\n자바17의 새로운 기능들, 3년 만에 LTS 버전 릴리즈\nJava 17로 전환을 고려해야 하는 이유\n우리팀이 JDK17을 도입한 이유\nJDK17 이제는 AdoptOpenJDK 대신 Eclipse Temurin 사용","개인적인-생각#개인적인 생각":"이 글을 처음 썼을 때는 1년전인 2023년도 3월이었고, 지금은 새로운 버전으로 글을 쓰고 있습니다. 현 시점에서 Java 보다는 Kotlin 을 선호하는 편이지만 Java 는 무시할 수 없는 가장 편한 언어로 생각하고 있습니다. 만약 프로젝트를 새로한다면 Java 17 을 선택하게 될 것 같습니다.Java 17 은 LTS 버전이며 버그픽스도 많이 되어 있는 편이기에 어느 정도의 최신 Java 스펙을 갖추고 있으면서 오랫동안 지원이 되는 Java 버전을 원한다면 Java 17 을 선택하는 것도 나쁘지 않은 선택으로 보입니다. 또한 Java 11 ~ 16 사이에 추가된 문법적인 편의성을 두루 포함하고 있습니다.","요약#요약":"LTS 주기 변경\nJDK 17 부터 LTS 버전에 대한 주기를 2년으로 변경 (JDK 17 이전에는 LTS 주기가 3년)\n2021년 9월 발표된 JDK 17의 다음 LTS 버전은 2년 후인 2023년 9월에 발표될 예정 (이글을 쓰는 현재날짜는 2023년 3월 19일)\n참고) LTS 주기 변경하기 전에는 2024년 9월 발표 예정이었다.\n새로운 라이선스 적용\nJDK 17부터는 NTFC (Oracle No-Fee Terms and Conditions) 라이선스를 적용해서 배포.\nJDK 17 이전에는 OTN (Oracle Technology Network) 라이선스.\nNTFC 라이선스에서는 개발자들이 많이 사용하는 SDKMAN 과 같은 배포,설치 툴을 이용해 Oracle JDK를 받을 수 있다. 다만, 배포의 경우 추가로 비용을 받지 않는 경우에만 허용된다. (참고. oracke jdk 배포를 의미함.)\n참고) JDK 17 기여도\nJDK Bug System 에 등록된 2645 개의 버그 중 1774개 외의 871 개의 문제점들을 다른 기관들의 참여로 이루어졌다고 함\nJEP 406, Preview. Switch~Case 문에 Pattern Matching 사용가능\ncase 문을 람다 기반으로 작성 가능하다. 이때 null 데이터도 조금 더 간편하게 다룰 수 있게 되었다.\n다만 아직 여전히 Preview 단계다.\ne.g.\npublic void printHello(String s){\r\nswitch(s){\r\ncase null -> System.out.println(\"널 이에요\"); \r\ncase \"hello\", \"world\" -> System.out.println(\"안녕하세요\");\r\ndefault -> System.out.println(\"디폴트\");\r\n}\r\n}\ncase 문에 기본타입 외에도 모든 참조 타입을 사용할 수 있게 되었다.\n이전에는 primitive 타입(기본타입), 일치하는 박스 타입(Character, Byte, Short, Integer 등), String, enum 타입만 허용됐었다.\ne.g.\nrecord Point(int i, int j) {}\r\nenum Color { RED, GREEN, BLUE; }\r\n\r\nstatic void typeTester(Object o) {\r\n\tswitch (o) {\r\n\t\tcase null     -> System.out.println(\"null\");\r\n\t\tcase String s -> System.out.println(\"String\");\r\n\t\tcase Color c  -> System.out.println(\"Color with \" + Color.values().length + \" values\");\r\n\t\tcase Point p  -> System.out.println(\"Record class: \" + p.toString());\r\n\t\tcase int[] ia -> System.out.println(\"Array of ints of length\" + ia.length);\r\n\t\tdefault       -> System.out.println(\"Something else\");\r\n\t}\r\n}\ninstanceof 사용 문법 간소화\ne.g.\n기존 : if(o instanceof String){ ... }\n자바17 : if(o instanceof String s) { ... }\n변수 s를 사용하는 코드를 if 문 안에서 사용 가능하다.\nJEP 409 sealed class\n코틀린에서 사용하는 sealed class와 거의 유사한 기능이 지원된다.\nsealed class 는 JDK15 에서 Preview (JEP 360) 로 제안되었고, JDK 16 에서 Second Preview (JEP 397)로 수정제안된 이력이 있다."}},"/":{"title":"Introduction","data":{"":"JVM\nJava 8 ~ 21 Features\nObject"}},"/java-features/java-21":{"title":"Java 21","data":{"java-21#Java 21":"정리 예정!!"}},"/java-features/java-8":{"title":"Java 8","data":{"java-8#Java 8":"꽤 오래된 버전이기에 시간이 될때 정리를 시작할 예정입니다.\nCompletableFuture, CompletableStage\nLocalDate, LocalDateTime, OffsetDateTime, ZonedDateTime\nStream API\nlambda, 함수형 인터페이스\nOptional"}},"/java-features/java-9":{"title":"Java 9","data":{"java-9#Java 9":"","참고자료#참고자료":"일반적인 GC와 G1GC\nG1GC의 라이프사이클, 장단점, heap 구조","요약#요약":"디폴트 메서드에도 package private 지정 가능\ntry with resource\n과거 방식 : try 내부 불록에 인라인으로 선언되어야 하는 방식\nJava 9 이후의 방식 : try 외부에서 자원을 선언해도 가능\n익명객체 생성 시에 다이아몬드 연산자 지원\n불변 컬렉션 API\ne.g. List.of(\"1\", \"2\", \"3\")\ne.g. Set.of(1,2,3)\ne.g. Map.of(\"1\":1, \"2\",2)\nOptional.stream()\nOptional 객체 역시 Stream 으로 처리할 수 있게 되었다.\nG1GC\nJDK 9 에서부터 G1 가비지 컬렉터가 디폴트 GC. 하지만 Java 9 까지는 Full GC는 싱글 스레드 기반 Mark Sweep Compact 알고리즘.\nRegion 을 일정한 크기로 나누어 객체를 할당한다. G1GC는 Region 을 튜닝하고 이에 따라 stop the world 를 최소화한다.\nJShll 커맨드 라인 툴 도입\n새로운 Http Client 도입 (HttpRequest)\n프로세스 API (ProcessHandle클래스)\nJCMD 커맨드 라인툴\nPublish, Subscriber 프레임워크\n통합 JVM 로깅\nJVM 로깅을 제공하는 공통 기능이 생겼는데, 각 모듈별로 독자적으로 공통기능을 사용해 독자적으로 로깅을 수행할 수 있는 로깅이 Java 9 부터 도입"}},"/lombok-effective-how-to":{"title":"Lombok Effective How To","data":{"롬복-효율적으로-쓰자#롬복, 효율적으로 쓰자":""}},"/jvm":{"title":"Jvm","data":{}},"/object/9-flexible-design":{"title":"9 Flexible Design","data":{"9-유연한-설계#9. 유연한 설계":"","참고자료#참고자료":"오브젝트","함께-생각해볼만한-자료#함께 생각해볼만한 자료":"초식 - 의존방향 생각하기","01-개방-폐쇄-법칙-open-closed-principle-ocp#01. 개방-폐쇄 법칙 (Open-Closed Principle, OCP)":"","ocpopen-closed-principle-ocp-로버트-마틴#OCP(Open-Closed Principle, OCP), 로버트 마틴":"로버트 마틴은 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나로 개방 폐쇄 원칙(Open-Closed Principle, OCP)을 고안했다.\n로버트 마틴이 이야기하는 OCP는 아래와 같다.\n소프트웨어 개체(클래스, 모듈,함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.\n개방 폐쇄 원칙 관점에서 유연한 설계라는 것은 기존의 코드를 수정하지 않고도(=수정에 닫혀있고) 애플리케이션의 동작을 확장할 수 있는 설계(=확장에는 열려있다.)를 의미한다\n개방 폐쇄 원칙을 지키는 설계를 하다보면, 결과적으로는 일반적으로 아래의 원칙을 따르게 된다.\n컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라\n추상화가 핵심이다.","컴파일-타임-의존성을-고정시키고-런타임-의존성을-변경하라#컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라.":"개방-폐쇄 원칙은 사실 런타임 의존성과 컴파일 의존성에 관한 이야기다.\n런타임 의존성은 실행 시에 협력에 참여하는 객체들 사이의 관계다.\n컴파일 타임 의존성은 코드에서 드러나는 클래스들 사이의 관계다.\n개방-폐쇄 원칙을 지키는 코드는 컴파일 타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.","eg-새로운-영화-할인-정책-추가시-ocp-원칙#e.g. 새로운 영화 할인 정책 추가시 OCP 원칙":"새로운 영화 할인 정책으로 중복할인 정책인 \"OverlappedDiscountPolicy\" 를 추가하는 예를 들어보자.\n새로운 할인 정책인 OverlappedDiscountPolicy 를 추가할 때 기존 코드를 수정하면 컴파일 의존성을 해치게 된다. 대신 DiscountPolicy 라는 타입으로 할인 정책을 주입받도록 하고, 런타임 의존성으로 OverlappedDiscountPolicy 객체를 생성해서 DiscountPolicy 에 바인딩해주면, 기존 코드(컴파일 의존성)은 수정하지 않으면서 런타임에 새로운 기능이 추가될 수 있게 된다.","추상화가-핵심이다#추상화가 핵심이다.":"개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.\r\n'추상화', '의존' 이 두 단어에 주목하자.\n추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.\n공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.\n이렇게 공통적인 부분이라는 것은 추상화를 의미한다.\n이렇게 추상화로 분류한 부분은 수정에 대해 닫혀 있어야 한다.\n이렇게 추상화를 통해 생략된 부분은 확장의 여지를 남긴다. 이렇게 확장의 여지를 남기는 것을 통해 개방-폐쇄 원칙을 가능하게 만들어준다.","변하지-않는-부분-vs-변하는-부분#변하지 않는 부분 vs 변하는 부분":"참고\nDiscountCondition\nDiscountPolicy\n(1) : 변하지 않는 부분\n아래 코드에서 할인 여부를 판단하는 로직이다.\nisSatisfiedBy(Screening) 은 어디에서든 공통으로 쓰여야 한다.\nisSatisfiedBy(Screening) 을 추상화된 클래스로 분류해 수정에 닫혀있도록 해주었다.\nPeriodCondition, SequenceCondition 클래스는 DiscountCondition 이라는 interface의 구현체(implement)다.\n(2) : 변하는 부분\n아래 코드에서 변하는 부분은 할인 요금을 계산하는 방법이다.\nDiscountPolicy 를 상속해서 생략된 부분을 오버라이딩(구체화)하면 할인 정책을 확장할 수 있게 된다.\nDiscountPolicy 를 확장하는 클래스인 AmountDiscountPolicy, PercentDiscountPolicy, NoDiscountPolicy 는 각각 getDiscountAmount(Screening) 에 대한 구현 부분이 각각 다르다.\n즉, AmountDiscountPolicy, PercentDiscountPolicy, NoDiscountPolicy 는 각각 할인 요금을 계산하는 방법이 다르다.\npackage org.eternity.movie.step01;\r\n\r\nimport org.eternity.money.Money;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic abstract class DiscountPolicy {\r\n    private List<DiscountCondition> conditions = new ArrayList<>();\r\n\r\n    public DiscountPolicy(DiscountCondition ... conditions) {\r\n        this.conditions = Arrays.asList(conditions);\r\n    }\r\n\r\n    public Money calculateDiscountAmount(Screening screening) {\r\n        for(DiscountCondition each : conditions) {\r\n\t\t\t// 변하지 않는 부분 : 할인 여부를 판단하는 로직\r\n            if (each.isSatisfiedBy(screening)) { // -- (1)\r\n                return getDiscountAmount(screening);\r\n            }\r\n        }\r\n\r\n        return screening.getMovieFee();\r\n    }\r\n\r\n\t// 변하는 부분 : 할인 요금을 계산하는 방법\r\n\t// -- (2)\r\n    abstract protected Money getDiscountAmount(Screening Screening);\r\n}","02-생성-사용-분리#02. 생성, 사용 분리":"","객체-생성과-객체-사용로직이-혼재하는-것의-문제점#객체 생성과 객체 사용로직이 혼재하는 것의 문제점":"객체 생성 역시 개방 폐쇄 원칙을 위배하게끔 한다. 객체 생성을 하는 로직은 수정사항 발생시 동작의 추가 변경을 발생시킨다.\r\n특히 클래스 내에서 다른 객체를 생성하는 코드는 해당 객체에 대한 지식을 요구하기에 결합도를 높이는 요인이 되기도 한다.이렇게 객체를 생성하는 부분을 분리하는 보편적인 방법은 객체 생성에 대한 책임을 클라이언트 역할을 하는 별도의 클래스 내의 메서드로 따로 옮기는 것이다.","객체-생성-로직을-일반-코드에서-분리하는-일반적인-방법들#객체 생성 로직을 일반 코드에서 분리하는 일반적인 방법들":"객체 생성 로직은 아래와 같은 클래스/메서드에 따로 분리해두면, 개방/폐쇄 원칙을 지킬 수 있게 된다.\n클라이언트 역할의 클래스\nFactory 클래스\n순수한 가공물 (Pure Fabrication)","03-의존성-주입#03. 의존성 주입":"","의존성-주입#의존성 주입":"객체의 생성과 객체의 사용을 분리하고 나면 인스턴스를 사용하는 책임만 남겨지게 된다.\r\n즉, 인스턴스를 사용하는 로직만 남겨지게 된다.\r\n사용하려고 하는 인스턴스는 객체의 외부에서 생성해서 전달해줘야 사용이 가능한데, 이렇게 객체를 외부에서 생성해서 전달해주는 방식을 의존성 주입이라고 한다.\n괜히 개념이 조금 어렵게 느껴질수도 있겠다.\r\n흔히 메서드 파라미터로 원하는 객채를 명시하고 외부에서 사용시에 해당 객체에 대한 구현체를 주입하는 것도 일종의 의존성 주입이다.\r\ngetter, setter, 생성자 주입만을 떠올릴 수 있지만, 테스트가 가능한 코드를 작성하다보면 메서드의 파라미터로 객체를 지정하는 경우가 많다. 이런 경우도 의존성 주입을 하는 하나의 예다.\n이렇게 생성자 주입이든, getter/setter 주입이든, 메서드 주입이든 외부의 독립적인 객체로부터 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방식을 의존성 주입(Dependency Injection)[Fowler04]이라고 부른다.\n참고\n스프링의 의존성 주입은 프레임워크 레벨에서 Bean 을 찾아서 주입해주는 것을 의미한다.","의존성-주입은-숨겨진-의존성의-단점을-해결할-수-있다#의존성 주입은 숨겨진 의존성의 단점을 해결할 수 있다.":"의존성을 이해하기 위해 다른 코드의 내부를 읽을 필요가 없다. 따라서 캡슐화를 이룰 수 있고, 객체의 캡슐을 단단하게 보호한다.\r\n객체 생성을 위해 필요한 인자값, 객체 생성시 수행하는 객체 내부의 동작 등\n의존성과 관련된 문제를 최대한 컴파일 타임에 잡아낼 수 있다.\n필요한 의존성을 인자에 추가하지 않으면 컴파일 타임에 에러가 발생하기 때문","요약#요약":"의존성 주입이란?\r\n외부에서 의존성을 해결하고, 이것을 사용하는 객체에 주입하는 동작을 의미\n3가지 의존성 주입 방식\n생성자 주입 : 객체를 생성하는 시점에 생성자를 통해 의존성 해결\nsetter 주입 : 객체 생성 후 setter 메서드를 호출해 의존성 해결\n메서드 주입 : 메서드 실행 시 인자를 이용해 의존성 해결\ne.g. 생성자 주입\nMovie avatar = new Movie(\"아바타\",\r\n\t\t\t\t\tDuration.ofMillis(120),\r\n\t\t\t\t\tMoney.wons(10000),\r\n\t\t\t\t\tnew AmountDiscountPolicy(...)\r\n\t\t\t\t);","04-의존성-역전-dependency-inversion-principle-dip-로버트-마틴martin02#04. 의존성 역전 (Dependency Inversion Principle, DIP, 로버트 마틴)[Martin02]":"의존성 역전 원칙(로버트 마틴)\n상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.\n추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다."}},"/object/3-cowork-responsibility-role":{"title":"3 Cowork Responsibility Role","data":{"3-협력-책임-역할#3. 협력, 책임, 역할":"","참고자료#참고자료":"오브젝트","협력-책임-역할-이란#협력, 책임, 역할 이란?":"","협력#협력":"어떤 객체가 다른 객체에게 무엇인가를 요청하는 것을 협력이라고 한다.\r\n객체 상의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.(Wirfs-Brock03)\r\n협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다.\r\n협력은 책임을 이끌어내고, 책임이 협력에 참여할 객체를 결정한다.\ne.g.\nScreening 은 Movie 객체에 메시지를 전송한다.\nScreening 은 Movie 객체와 협력하고 있다.","책임#책임":"협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다.\r\n책임은 객체가 어떤 행동을 해야할 지를 사람의 화법으로 표현한 것이다.\n참고) 책임할당, 책임주도설계, 책임과 협력","역할#역할":"역할은 책임의 집합을 의미한다.\r\n여러 종류의 책임은 하나의 역할로 추상화할 수 있다.\r\n어떤 책임(메시지)가 여러 종류의 객체에서 사용된다면, 이 여러 종류의 책임 객체들을 역할로 분류한다.\r\n책임은 구체(concrete) 개념이고, 역할은 추상(abstract) 개념이다.\r\n여러 종류의 책임에서 공통점을 찾아내서 역할이라는 추상클래스/인터페이스로 분류할 수 있다.\ne.g. 책임\n금액할인(AmountDiscountPolicy), 비율할인(PercentDiscountPolicy), 무할인(NoneDiscountPolicy) 객체들에 공통적으로 존재하는 calculateDiscountAmount() 메서드\ne.g. 역할\nDiscountPolicy\nAmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체에 대해 DiscountPolicy 라는 이름의 하나의 역할 클래스로 정의한다.","협력-1#협력":"","협력-설계-시-거치는-주요-원칙#협력 설계 시 거치는 주요 원칙":"1) 객체는 자신의 일을 스스로 처리할 수 있는 자율적인 존재여야 한다.\nMovie 객체는 자율적인 존재가 되기 위해서는 요금 계산을 스스로 처리할 수 있어야 한다.\n2) 협력이 설계를 위한 문맥을 제공한다.\n상태, 행동을 정의하면서 협력관계가 도출되고 객체를 설계하는 데에 있어서 필요한 문맥(Context)가 도출된다.\n3) 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.\r\ne.g. Screening 이 Movie, DiscountPolicy, Screening 같은 캡슐화된 객체를 통해 Screening 의 역할을 수행하고, 캡슐화 된 Movie, DiscountPolicy, Screening 역시 외부에 영향없이 자율적으로 역할을 수행","1-객체는-자신의-일을-스스로-처리할-수-있는-자율적인-존재여야-한다#1) 객체는 자신의 일을 스스로 처리할 수 있는 자율적인 존재여야 한다.":"Movie 객체는 영화 요금 계산을 자율적으로 처리할 수 있다.\r\n자신이 할 수 없는 할인요금 계산은 DiscountPolicy 에 위임해 할인 금액을 얻어온다.\r\n다른 코드의 상수 코드나 상태에 종속적이지 않다. 필요한 다른 계산, 처리는 객체에 위임해서 얻어오고 자신의 역할을 한다.\npublic class Movie{\r\n\tprivate Money fee;\t// 생성자 주입\r\n\tprivate DiscountPolicy discountPolicy; \t// 생성자 주입\r\n\r\n\t// ...\r\n\r\n\tpublic Money calculateMovieFee(Screening screening){\r\n\t\treturn fee.minus(discountPolicy.calculateDiscountAmount(screening));\r\n\t}\r\n}","2-협력이-설계를-위한-문맥을-제공한다-상태-행동-협력관계#2) 협력이 설계를 위한 문맥을 제공한다. (상태, 행동, 협력관계)":"상태, 행동을 정의하면서 협력관계가 도출되고 객체를 설계하는 데에 있어서 필요한 문맥(Context)가 도출된다.\n상태란 객체가 어떤 행동을 하는 데에 필요한 정보다.\r\n행동은 협력 내에서 객체가 처리할 메시지다.협력 설계시 상태, 행동을 고려해 설계를 하면 협력을 통해 행동을 하게 되고, 행동은 상태를 필요로 한다.협력관계를 통해서 객체를 설계하는 데에 있어서 필요한 문맥(Context)가 도출된다.","3-객체를-자율적으로-만드는-가장-기본적인-방법은-내부-구현을-캡슐화하는-것이다#3) 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.":"자율적인 객체를 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다. 이렇게 캡슐화를 통해 변경으로 인한 파급효과(Side Effect)를 줄일 수 있다.\npublic class Movie{\r\n\tprivate Money fee; // 생성자 주입\r\n\tprivate DiscountPolicy discountPolicy; // 생성자 주입\r\n\r\n\t// ...\r\n\r\n\tpublic Money calculateMovieFee(Screening screening){\r\n\t\treturn fee.minus(discountPolilcy.calculateDiscountAmount(screening));\r\n\t}\r\n}","책임-1#책임":"협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다.\r\n책임은 객체가 어떤 행동을 해야할 지를 사람의 화법으로 표현한 것이다.\r\n“책임을 수행한다.” 는 말은 “메시지를 전송한다.” 라는 말로도 표현된다.\n참고) 책임할당, 책임주도설계, 책임과 협력","책임할당#책임할당":"책임을 할당하는 것은 메시지의 이름을 결정하는 것과 같다.책임할당 과정에서는 아래의 두 과정을 끊임없이 반복한다.\n메시지의 이름을 결정한다. (책임에 대한 이름을 짓는다.)\n메시지를 처리할 객체를 결정한다. (책임을 수행할 객체를 선택)","책임주도-설계-rdd-responsibility-driven-design#책임주도 설계 (RDD, Responsibility-Driven Design)":"책임을 찾고 책임을 수행할 적절한 객체를 찾아서 책임을 할당하는 방식으로 협력을 설계하는 방식을 책임주도 설계(Responsibility-Driven Design, RDD) 라고 부른다.\ne.g. Movie 객체는 자율적인 존재가 되기 위해서는 요금 계산을 스스로 처리할 수 있어야 한다.\n책임주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있게 한다.\n처음부터 객체를 구현해나가면서 리팩토링하는 것이 아니라 기능의 리스트업을 통해 세부적인 메시지를 정의하고\r\n이것을 수행할 객체를 선택하는 과정을 거친다. 이렇게 하면 결국 책임을 기반으로 결정을 하게 된다.","책임할당할-객체-선택-시-주요-원칙#책임할당할 객체 선택 시 주요 원칙":"1) 메시지가 객체를 결정한다.\n메시지가 객체를 결정하게 해야 한다. 객체가 메시지를 결정하게 하는 것이 아니다.\n메시지가 객체를 결정하게끔 하면, 아래의 두 장점을 얻는다.\n객체가 최소한의 인터페이스를 갖게된다.\n추상적인 인터페이스를 가질 수 있게 된다.\n2) 행동이 상태를 결정한다. 행동이 객체의 책임이 되어야 한다.\n객체는 협력에 필요한 행동을 제공해야 한다. 객체의 상태가 아닌 행동이 중요하다. (객체의 상태는 행동이 결정되어야 상태가 결정된다.)\n객체의 행동이 아닌 상태에 초점을 맞출 경우 캡슐화가 저해되는 결과를 낳는다.\n행동이 아닌 상태에 초점을 맞추는 실수(상태를 먼저 결정하고 행동을 결정)를 유의해야 한다.\n객체의 상태에 초점을 맞춰 구현을 하면 내부 구현이 퍼블릭 인터페이스로 노출된다. 이때 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경된다. 이러면 결국 클라이언트 계층까지 변경의 영향이 전파된다.\n행동이 상태를 결정하지 않고 상태를 먼저 정의후 행동을 정의하는 방식은 데이터 주도 설계(Data Driven Design)라고 부른다. (레베카 워스트브룩)","책임주도-설계-rdd-responsibility-driven-design-를-하는-과정#책임주도 설계 (RDD, Responsibility-Driven Design) 를 하는 과정":"시스템의 책임을 파악한다. (시스템의 책임은 시스템이 사용자에게 제공해야 하는 기능을 의미)\n시스템의 책임을 더 작은 책임으로 분할한다.\n분할된 책임을 수행할 수 있는 적절한 객체/역할을 찾아서 할당한다.\n객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이것을 책임질 적절한 객체/역할을 찾는다.\n해당 객체 또는 역할에게 책임을 할당하는 것으로 두 객체가 협력하게 한다.","책임과-협력#책임과 협력":"협력 관계 속에서 책임을 도출한다.\r\n책임은 책임을 수행할 객체를 선택해서 메시지를 어떤 객체에서 수행할지를 결정한다.\r\n이렇게 결정한 객체에 대한 책임(메서드)은 다른 객체와 협력관계를 갖는다.\r\n책임을 통해 객체가 행동을 하는데, 행동은 다른 객체와 협력관계를 맺는다. 따라서 협력과 책임은 서로 연관된 개념이다.","역할-1#역할":"역할은 책임의 집합을 의미한다.\r\n여러 종류의 책임은 하나의 역할로 추상화할 수 있다.\r\n어떤 책임(메시지)가 여러 종류의 객체에서 사용된다면, 이 여러 종류의 책임 객체들을 역할로 분류한다.\r\n책임은 구체(concrete) 개념이고, 역할은 추상(abstract) 개념이다.\r\n여러 종류의 책임에서 공통점을 찾아내서 역할이라는 추상클래스/인터페이스로 분류할 수 있다.\ne.g. 책임\n금액할인(AmountDiscountPolicy), 비율할인(PercentDiscountPolicy), 무할인(NoneDiscountPolicy) 객체들에 공통적으로 존재하는 calculateDiscountAmount()\ne.g. 역할\nDiscountPolicy 와 같은 여러 책임들을 추상화할 수 있는 추상화 클래스를 역할 클래스라고 한다.\nAmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체에 대해 DiscountPolicy 라는 이름의 하나의 역할 클래스로 정의한다.","역할과-추상화#역할과 추상화":"역할은 추상화를 이용해 공통의 책임ㅇ르 바탕으로 객체의 종류를 숨긴다.\r\n역할을 사용하면 아래의 두 장점을 갖게 된다. (2장. 추상화 참고)\n중요한 정책을 추상화해서 상위 수준에서 단순화할 수 있다.\n세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다.\ne.g. 금액할인 정책, 비율할인 정책을 순번/기간 조건과 조합해 다양한 방식의 요금 규칙을 설정할 수 있게 된다.\n설계가 조금 더 유연해진다.\n다양한 종류의 객체를 끼워넣을 수 있도록 하나의 추상화된 클래스인 DiscountPolicy 를 도입했다는 사실을 기억하자.","책임에서부터-역할로-분류해가는-과정#책임에서부터 역할로 분류해가는 과정":"책임 정의\r\n객체가 수행하는 행동을 메시지로 정의한다. 이렇게 객체가 수행하는 메시지를 책임 이라고 부른다.\n역할 도출\r\n특정 메시지는 특정 상황(e.g. 할인가격 계산)속 에서 특정 객체들이 같은 이름의 메시지를 갖는 경우가 있다.\r\n이렇게 같은 이름의 메시지가 여러 객체에 존재할 때 이것을 공통된 객체 내의 메시지로 추상화를 하는데, 이것을 역할이라고 한다.\ne.g. 책임\n금액할인(AmountDiscountPolicy) 객체의 calculateDiscountAmount()\n비율할인(PercentDiscountPolicy) 객체의 calculateDiscountAmount()\n무할인(NoneDiscountPolicy) 객체의 calculateDiscountAmount()\ne.g. 역할\nDiscountPolicy 로 추상화\nAmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체에 대해 DiscountPolicy 라는 이름의 하나의 역할 클래스로 정의하고 DiscountPolicy 클래스는 추상 메서드로 calculateDiscountAmount() 를 갖는다.\ne.g. 그림으로 정리해보면 아래와 같다.","eg-역할에-책임을-할당한-코드#e.g. 역할에 책임을 할당한 코드":"DiscountPolicy 는 AmountDiscountPolicy, PercentDiscountPolicy, NoneDiscountPolicy 객체를 대체할 수 있는 추상화 클래스다.\npublic class Movie{\r\n\t\r\n\t// ...\r\n\r\n\tprivate DiscountPolicy discountPolicy; // 생성자 주입\r\n\r\n\tpublic Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy){\r\n\t\t// ...\r\n\t\tthis.discountPolicy = discountPolicy;\r\n\t}\r\n\r\n\t// ...\r\n\r\n\tpublic Money calculateMovieFee(Screening screening){\r\n\t\treturn fee.minus(\r\n\t\t\tdiscountPolicy.calculateDiscountAmount(screening);\r\n\t\t);\r\n\t}\r\n}"}},"/tdd":{"title":"Tdd","data":{"tdd#TDD":"모르겠다. 걍 시간날 때 마다 꾸준히!!!"}},"/object":{"title":"Object","data":{"":"Object 의 주요 내용들을 요약\n참고도서\n오브젝트"}}}